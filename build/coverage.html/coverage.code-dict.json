{"/home/travis/build/npmtest/node-npmtest-actionhero/test.js":"/* istanbul instrument in package npmtest_actionhero */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-actionhero/lib.npmtest_actionhero.js":"/* istanbul instrument in package npmtest_actionhero */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_actionhero = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_actionhero = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-actionhero/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-actionhero && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_actionhero */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_actionhero\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_actionhero.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_actionhero.rollup.js'] =\n            local.assetsDict['/assets.npmtest_actionhero.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_actionhero.__dirname + '/lib.npmtest_actionhero.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-actionhero/node_modules/actionhero/actionhero.js":"'use strict'\n\n// //////////////////////////////////////////////////////////////////////////\n// actionhero framework in node.js\n// http://www.actionherojs.com\n// https://github.com/actionhero/actionhero\n\nconst path = require('path')\nconst async = require('async')\n\n// HELPERS ///\n\nconst fatalError = function (api, errors, type) {\n  if (errors && !(errors instanceof Array)) { errors = [errors] }\n  if (errors) {\n    if (api.log) {\n      api.log(['Error with initializer step: %s', type], 'emerg')\n      errors.forEach((error) => { api.log(error.stack, 'emerg') })\n    } else {\n      console.error('Error with initializer step: ' + type)\n      errors.forEach((error) => { console.error(error.stack) })\n    }\n    api.commands.stop.call(api, () => {\n      process.exit(1)\n    })\n  }\n}\n\nconst sortNumber = function (a, b) {\n  return a - b\n}\n\nlet startCount = 0\n\nconst flattenOrderedInitialzer = function (collection) {\n  let output = []\n  let keys = []\n  for (let key in collection) {\n    keys.push(parseInt(key))\n  }\n  keys.sort(sortNumber)\n  keys.forEach((key) => {\n    collection[key].forEach((d) => {\n      output.push(d)\n    })\n  })\n\n  return output\n}\n\n// ACTIONHERO //\n\nconst actionhero = function () {\n  this.initializers = {}\n  this.api = {\n    running: false,\n    initialized: false,\n    shuttingDown: false\n  }\n}\n\nactionhero.prototype.initialize = function (params, callback) {\n  this.api.commands = {\n    initialize: (params, callback) => { this.initialize(params, callback) },\n    start: (params, callback) => { this.start(params, callback) },\n    stop: (callback) => { this.stop(callback) },\n    restart: (callback) => { this.restart(callback) }\n  }\n\n  this.api.projectRoot = process.cwd()\n\n  if (process.env.project_root) {\n    this.api.projectRoot = process.env.project_root\n  } else if (process.env.projectRoot) {\n    this.api.projectRoot = process.env.projectRoot\n  } else if (process.env.PROJECT_ROOT) {\n    this.api.projectRoot = process.env.PROJECT_ROOT\n  }\n\n  if (!callback && typeof params === 'function') {\n    callback = params; params = {}\n  }\n  if (params === null) { params = {} }\n  this.startingParams = params\n  this.api._startingParams = this.startingParams\n\n  this.api.initializerDefaults = {\n    load: 1000,\n    start: 1000,\n    stop: 1000\n  }\n\n  let loadInitializerRankings = {}\n  let startInitializerRankings = {}\n  let stopInitializerRankings = {}\n\n  this.configInitializers = []\n  this.loadInitializers = []\n  this.startInitializers = []\n  this.stopInitializers = [];\n\n  // we need to load the config first\n  [\n    path.resolve(__dirname, 'initializers', 'utils.js'),\n    path.resolve(__dirname, 'initializers', 'config.js')\n  ].forEach((file) => {\n    let filename = file.replace(/^.*[\\\\/]/, '')\n    let initializer = filename.split('.')[0]\n    delete require.cache[require.resolve(file)]\n    this.initializers[initializer] = require(file)\n    this.configInitializers.push((next) => {\n      this.initializers[initializer].initialize(this.api, next)\n    })\n  })\n\n  this.configInitializers.push(() => {\n    let customInitializers = []\n    let duplicatedInitializers = []\n    this.api.config.general.paths.initializer.forEach((startPath) => {\n      customInitializers = customInitializers.concat(this.api.utils.recursiveDirectoryGlob(startPath))\n    })\n    // load all other initializers\n    this.api.utils.arrayUniqueify(\n      this.api.utils.recursiveDirectoryGlob(path.join(__dirname, 'initializers'))\n      .sort()\n      .concat(\n        customInitializers\n        .sort()\n      )\n    ).forEach((f) => {\n      let file = path.normalize(f)\n      let initializer = path.basename(f).split('.')[0]\n      let fileParts = file.split('.')\n      let ext = fileParts[(fileParts.length - 1)]\n      if (ext === 'js') {\n        // check if initializer already exists (exclude utils and config)\n        if (this.initializers[initializer] &&\n           file !== path.resolve(__dirname, 'initializers', 'utils.js') &&\n           file !== path.resolve(__dirname, 'initializers', 'config.js')) {\n          duplicatedInitializers.push(file)\n        } else {\n          delete require.cache[require.resolve(file)]\n          this.initializers[initializer] = require(file)\n        }\n\n        const loadFunction = (next) => {\n          this.api.watchFileAndAct(file, () => {\n            this.api.log(['*** Rebooting due to initializer change (%s) ***', file], 'info')\n            this.api.commands.restart()\n          })\n\n          if (typeof this.initializers[initializer].initialize === 'function') {\n            if (typeof this.api.log === 'function') { this.api.log(['Loading initializer: %s', initializer], 'debug', file) }\n            this.initializers[initializer].initialize(this.api, (error) => {\n              try { this.api.log(['Loaded initializer: %s', initializer], 'debug', file) } catch (e) { }\n              next(error)\n            })\n          } else {\n            next()\n          }\n        }\n\n        const startFunction = (next) => {\n          if (typeof this.initializers[initializer].start === 'function') {\n            if (typeof this.api.log === 'function') { this.api.log(['Starting initializer: %s', initializer], 'debug', file) }\n            this.initializers[initializer].start(this.api, (error) => {\n              this.api.log(['Started initializer: %s', initializer], 'debug', file)\n              next(error)\n            })\n          } else {\n            next()\n          }\n        }\n\n        const stopFunction = (next) => {\n          if (typeof this.initializers[initializer].stop === 'function') {\n            if (typeof this.api.log === 'function') { this.api.log(['Stopping initializer: %s', initializer], 'debug', file) }\n            this.initializers[initializer].stop(this.api, (error) => {\n              this.api.log(['Stopped initializer: %s', initializer], 'debug', file)\n              next(error)\n            })\n          } else {\n            next()\n          }\n        }\n\n        if (this.initializers[initializer].loadPriority === undefined) {\n          this.initializers[initializer].loadPriority = this.api.initializerDefaults.load\n        }\n        if (this.initializers[initializer].startPriority === undefined) {\n          this.initializers[initializer].startPriority = this.api.initializerDefaults.start\n        }\n        if (this.initializers[initializer].stopPriority === undefined) {\n          this.initializers[initializer].stopPriority = this.api.initializerDefaults.stop\n        }\n\n        if (loadInitializerRankings[this.initializers[initializer].loadPriority] === undefined) {\n          loadInitializerRankings[this.initializers[initializer].loadPriority] = []\n        }\n        if (startInitializerRankings[this.initializers[initializer].startPriority] === undefined) {\n          startInitializerRankings[this.initializers[initializer].startPriority] = []\n        }\n        if (stopInitializerRankings[this.initializers[initializer].stopPriority] === undefined) {\n          stopInitializerRankings[this.initializers[initializer].stopPriority] = []\n        }\n\n        if (this.initializers[initializer].loadPriority > 0) {\n          loadInitializerRankings[this.initializers[initializer].loadPriority].push(loadFunction)\n        }\n\n        if (this.initializers[initializer].startPriority > 0) {\n          startInitializerRankings[this.initializers[initializer].startPriority].push(startFunction)\n        }\n\n        if (this.initializers[initializer].stopPriority > 0) {\n          stopInitializerRankings[this.initializers[initializer].stopPriority].push(stopFunction)\n        }\n      }\n    })\n\n    // flatten all the ordered initializer methods\n    this.loadInitializers = flattenOrderedInitialzer(loadInitializerRankings)\n    this.startInitializers = flattenOrderedInitialzer(startInitializerRankings)\n    this.stopInitializers = flattenOrderedInitialzer(stopInitializerRankings)\n\n    this.loadInitializers.push(() => {\n      process.nextTick(() => {\n        this.api.initialized = true\n\n        if (duplicatedInitializers.length > 0) {\n          duplicatedInitializers.forEach(initializer => this.api.log(['Initializer %s already exists!', initializer], 'error'))\n          this.api.commands.stop.call(this.api, () => {\n            process.exit(1)\n          })\n        }\n        callback(null, this.api)\n      })\n    })\n\n    async.series(this.loadInitializers, (errors) => { fatalError(this.api, errors, 'initialize') })\n  })\n\n  async.series(this.configInitializers, (errors) => { fatalError(this.api, errors, 'config') })\n}\n\nactionhero.prototype.start = function (params, callback) {\n  if (!callback && typeof params === 'function') {\n    callback = params; params = {}\n  }\n\n  const _start = () => {\n    this.api.running = true\n\n    this.startInitializers.push(() => {\n      this.api.bootTime = new Date().getTime()\n      if (startCount === 0) {\n        this.api.log(['*** ActionHero Started ***'], 'alert')\n      } else {\n        this.api.log(['*** ActionHero Restarted ***'], 'alert')\n      }\n\n      startCount++\n      callback(null, this.api)\n    })\n\n    async.series(this.startInitializers, (errors) => { fatalError(this.api, errors, 'start') })\n  }\n\n  if (this.api.initialized === true) {\n    _start()\n  } else {\n    this.initialize(params, () => {\n      _start()\n    })\n  }\n}\n\nactionhero.prototype.stop = function (callback) {\n  if (this.api.running === true) {\n    this.api.shuttingDown = true\n    this.api.running = false\n    this.api.initialized = false\n\n    this.api.log('Shutting down open servers and stopping task processing...', 'notice')\n\n    this.stopInitializers.push(() => {\n      this.api.unWatchAllFiles()\n      this.api.pids.clearPidFile()\n      this.api.log('*** ActionHero Stopped ***', 'alert')\n      this.api.log('***', 'debug')\n      delete this.api.shuttingDown\n      // reset initializers to prevent duplicate check on restart\n      this.initializers = {}\n      process.nextTick(() => {\n        if (typeof callback === 'function') { callback(null, this.api) }\n      })\n    })\n\n    async.series(this.stopInitializers, (errors) => { fatalError(this.api, errors, 'stop') })\n  } else if (this.api.shuttingDown === true) {\n    // double sigterm; ignore it\n  } else {\n    if (this.api.log) { this.api.log('Cannot shut down actionhero, not running', 'error') }\n    if (typeof callback === 'function') { callback(null, this.api) }\n  }\n}\n\nactionhero.prototype.restart = function (callback) {\n  if (this.api.running === true) {\n    this.stop((error) => {\n      if (error) { this.api.log(error, 'error') }\n      this.start(this.startingParams, (error) => {\n        if (error) { this.api.log(error, 'error') }\n        if (typeof callback === 'function') { callback(null, this.api) }\n      })\n    })\n  } else {\n    this.start(this.startingParams, (error) => {\n      if (error) { this.api.log(error, 'error') }\n      if (typeof callback === 'function') { callback(null, this.api) }\n    })\n  }\n}\n\nmodule.exports = actionhero\n","/home/travis/build/npmtest/node-npmtest-actionhero/node_modules/actionhero/actions/cacheTest.js":"'use strict'\n\nexports.cacheTest = {\n  name: 'cacheTest',\n  description: 'I will test the internal cache functions of the API',\n\n  outputExample: {\n    cacheTestResults: {\n      saveResp: true,\n      sizeResp: 1,\n      loadResp: {\n        key: 'cacheTest_key',\n        value: 'value',\n        expireTimestamp: 1420953274716,\n        createdAt: 1420953269716,\n        readAt: null\n      },\n      deleteResp: true\n    }\n  },\n\n  inputs: {\n    key: {\n      required: true,\n      formatter: function (s) { return String(s) }\n    },\n    value: {\n      required: true,\n      formatter: function (s) { return String(s) },\n      validator: function (s) {\n        if (s.length < 3) {\n          return '`value` should be at least 3 letters long'\n        } else { return true }\n      }\n    }\n  },\n\n  run: function (api, data, next) {\n    const key = 'cacheTest_' + data.params.key\n    const value = data.params.value\n\n    data.response.cacheTestResults = {}\n\n    api.cache.save(key, value, 5000, function (error, resp) {\n      if (error) { return next(error) }\n      data.response.cacheTestResults.saveResp = resp\n      api.cache.size(function (error, numberOfCacheObjects) {\n        if (error) { return next(error) }\n        data.response.cacheTestResults.sizeResp = numberOfCacheObjects\n        api.cache.load(key, function (error, resp, expireTimestamp, createdAt, readAt) {\n          if (error) { return next(error) }\n          data.response.cacheTestResults.loadResp = {\n            key: key,\n            value: resp,\n            expireTimestamp: expireTimestamp,\n            createdAt: createdAt,\n            readAt: readAt\n          }\n          api.cache.destroy(key, function (error, resp) {\n            data.response.cacheTestResults.deleteResp = resp\n            next(error)\n          })\n        })\n      })\n    })\n  }\n\n}\n","/home/travis/build/npmtest/node-npmtest-actionhero/node_modules/actionhero/actions/createChatRoom.js":"'use strict'\n\nexports.createChatRoom = {\n  name: 'createChatRoom',\n  description: 'I will create a chatroom with the given name',\n\n  outputExample: {},\n\n  inputs: {\n    name: { required: true }\n  },\n\n  run: function (api, data, next) {\n    api.chatRoom.add(data.params.name, next)\n  }\n\n}\n","/home/travis/build/npmtest/node-npmtest-actionhero/node_modules/actionhero/actions/randomNumber.js":"'use strict'\n\nexports.randomNumber = {\n  name: 'randomNumber',\n  description: 'I am an API method which will generate a random number',\n  outputExample: {\n    randomNumber: 0.123\n  },\n\n  run: function (api, data, next) {\n    data.response.randomNumber = Math.random()\n    data.response.stringRandomNumber = data.connection.localize(['Your random number is %s', Math.random()])\n    next(null)\n  }\n\n}\n","/home/travis/build/npmtest/node-npmtest-actionhero/node_modules/actionhero/actions/showDocumentation.js":"'use strict'\n\nexports.showDocumentation = {\n  name: 'showDocumentation',\n  description: 'return API documentation',\n\n  outputExample: {\n    'documentation': {\n      'cacheTest': {\n        '1': {\n          'name': 'cacheTest',\n          'version': 1,\n          'description': 'I will test the internal cache functions of the API',\n          'inputs': {\n            'key': {\n              'required': true\n            },\n            'value': {\n              'required': true\n            }\n          },\n          'outputExample': {\n            'cacheTestResults': {\n              'saveResp': true,\n              'sizeResp': 1,\n              'loadResp': {\n                'key': '',\n                'value': 'value',\n                'expireTimestamp': 1420953274716,\n                'createdAt': 1420953269716,\n                'readAt': null\n              },\n              'deleteResp': true\n            }\n          }\n        }\n      },\n      'randomNumber': {\n        '1': {\n          'name': 'randomNumber',\n          'version': 1,\n          'description': 'I am an API method which will generate a random number',\n          'inputs': {\n\n          },\n          'outputExample': {\n            'randomNumber': 0.123\n          }\n        }\n      },\n      'showDocumentation': {\n        '1': {\n          'name': 'showDocumentation',\n          'version': 1,\n          'description': 'return API documentation',\n          'inputs': {\n\n          }\n        }\n      },\n      'sleepTest': {\n        '1': {\n          'name': 'sleepTest',\n          'version': 1,\n          'description': 'I will sleep and then return',\n          'inputs': {\n            'sleepDuration': {\n              'required': true\n            }\n          }\n        }\n      },\n      'status': {\n        '1': {\n          'name': 'status',\n          'version': 1,\n          'description': 'I will return some basic information about the API',\n          'inputs': {\n\n          }\n        }\n      }\n    }\n  },\n\n  run: function (api, data, next) {\n    data.response.documentation = api.documentation.documentation\n    next()\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-actionhero/node_modules/actionhero/actions/sleepTest.js":"'use strict'\n\nexports.sleepTest = {\n  name: 'sleepTest',\n  description: 'I will sleep and then return',\n\n  inputs: {\n    sleepDuration: {\n      required: true,\n      formatter: function (n) { return parseInt(n) },\n      default: function () { return 1000 }\n    }\n  },\n\n  outputExample: {\n    'sleepStarted': 1420953571322,\n    'sleepEnded': 1420953572327,\n    'sleepDelta': 1005,\n    'sleepDuration': 1000\n  },\n\n  run: function (api, data, next) {\n    const sleepDuration = data.params.sleepDuration\n    const sleepStarted = new Date().getTime()\n\n    setTimeout(function () {\n      const sleepEnded = new Date().getTime()\n      const sleepDelta = sleepEnded - sleepStarted\n\n      data.response.sleepStarted = sleepStarted\n      data.response.sleepEnded = sleepEnded\n      data.response.sleepDelta = sleepDelta\n      data.response.sleepDuration = sleepDuration\n\n      next()\n    }, sleepDuration)\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-actionhero/node_modules/actionhero/actions/status.js":"'use strict'\n\nconst path = require('path')\nconst packageJSON = require(path.normalize(path.join(__dirname, '..', 'package.json')))\n\n// These values are probably good starting points, but you should expect to tweak them for your application\nconst maxEventLoopDelay = process.env.eventLoopDelay || 10\nconst maxMemoryAlloted = process.env.maxMemoryAlloted || 200\nconst maxResqueQueueLength = process.env.maxResqueQueueLength || 1000\n\nexports.status = {\n  name: 'status',\n  description: 'I will return some basic information about the API',\n\n  outputExample: {\n    'id': '192.168.2.11',\n    'actionheroVersion': '9.4.1',\n    'uptime': 10469\n  },\n\n  run: function (api, data, next) {\n    /* --- Define Helpers --- */\n\n    const checkRam = function (callback) {\n      const consumedMemoryMB = Math.round(process.memoryUsage().heapUsed / 1024 / 1024 * 100) / 100\n      data.response.consumedMemoryMB = consumedMemoryMB\n      if (consumedMemoryMB > maxMemoryAlloted) {\n        data.response.nodeStatus = data.connection.localize('Unhealthy')\n        data.response.problems.push(data.connection.localize('Using more than ' + maxMemoryAlloted + 'MB of RAM/HEAP'))\n      }\n\n      callback()\n    }\n\n    const checkEventLoop = function (callback) {\n      api.utils.eventLoopDelay(10000, function (error, eventLoopDelay) {\n        if (error) { return callback(error) }\n        data.response.eventLoopDelay = eventLoopDelay\n        if (eventLoopDelay > maxEventLoopDelay) {\n          data.response.nodeStatus = data.connection.localize('Node Unhealthy')\n          data.response.problems.push(data.connection.localize('EventLoop Blocked for more than ' + maxEventLoopDelay + 'ms'))\n        }\n\n        callback()\n      })\n    }\n\n    const checkResqueQueues = function (callback) {\n      api.tasks.details(function (error, details) {\n        if (error) { return callback(error) }\n        let length = 0\n        Object.keys(details.queues).forEach(function (q) {\n          length += details.queues[q].length\n        })\n\n        data.response.resqueTotalQueueLength = length\n\n        if (length > maxResqueQueueLength) {\n          data.response.nodeStatus = data.connection.localize('Node Unhealthy')\n          data.response.problems.push(data.connection.localize('Resque Queues over ' + maxResqueQueueLength + ' jobs'))\n        }\n\n        callback()\n      })\n    }\n\n    /* --- Run --- */\n\n    data.response.nodeStatus = data.connection.localize('Node Healthy')\n    data.response.problems = []\n\n    data.response.id = api.id\n    data.response.actionheroVersion = api.actionheroVersion\n    data.response.uptime = new Date().getTime() - api.bootTime\n    data.response.name = packageJSON.name\n    data.response.description = packageJSON.description\n    data.response.version = packageJSON.version\n\n    checkRam(function (error) {\n      if (error) { return next(error) }\n      checkEventLoop(function (error) {\n        if (error) { return next(error) }\n        checkResqueQueues(function (error) {\n          next(error)\n        })\n      })\n    })\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-actionhero/node_modules/actionhero/client/actionheroClient.js":"var ActionheroClient = function (options, client) {\n  var self = this\n\n  self.callbacks = {}\n  self.id = null\n  self.events = {}\n  self.rooms = []\n  self.state = 'disconnected'\n\n  self.options = self.defaults()\n  for (var i in options) {\n    self.options[i] = options[i]\n  }\n\n  if (client) {\n    self.externalClient = true\n    self.client = client\n  }\n}\n\nif (typeof Primus === 'undefined') {\n  var util = require('util')\n  var EventEmitter = require('events').EventEmitter\n  util.inherits(ActionheroClient, EventEmitter)\n} else {\n  ActionheroClient.prototype = new Primus.EventEmitter()\n}\n\nActionheroClient.prototype.defaults = function () {\n  %%DEFAULTS%%\n}\n\n// //////////////\n// CONNECTION //\n// //////////////\n\nActionheroClient.prototype.connect = function (callback) {\n  var self = this\n  self.messageCount = 0\n\n  if (self.client && self.externalClient !== true) {\n    self.client.end()\n    self.client.removeAllListeners()\n    delete self.client\n    self.client = Primus.connect(self.options.url, self.options)\n  } else if (self.client && self.externalClient === true) {\n    self.client.end()\n    self.client.open()\n  } else {\n    self.client = Primus.connect(self.options.url, self.options)\n  }\n\n  self.client.on('open', function () {\n    self.configure(function (details) {\n      if (self.state === 'connected') {\n        //\n      } else {\n        self.state = 'connected'\n        if (typeof callback === 'function') { callback(null, details) }\n      }\n      self.emit('connected')\n    })\n  })\n\n  self.client.on('error', function (error) {\n    self.emit('error', error)\n  })\n\n  self.client.on('reconnect', function () {\n    self.messageCount = 0\n    self.emit('reconnect')\n  })\n\n  self.client.on('reconnecting', function () {\n    self.emit('reconnecting')\n    self.state = 'reconnecting'\n    self.emit('disconnected')\n  })\n\n  self.client.on('timeout', function () {\n    self.state = 'timeout'\n    self.emit('timeout')\n  })\n\n  self.client.on('close', function () {\n    self.messageCount = 0\n    if (self.state !== 'disconnected') {\n      self.state = 'disconnected'\n      self.emit('disconnected')\n    }\n  })\n\n  self.client.on('end', function () {\n    self.messageCount = 0\n    if (self.state !== 'disconnected') {\n      self.state = 'disconnected'\n      self.emit('disconnected')\n    }\n  })\n\n  self.client.on('data', function (data) {\n    self.handleMessage(data)\n  })\n}\n\nActionheroClient.prototype.configure = function (callback) {\n  var self = this\n\n  self.rooms.forEach(function (room) {\n    self.send({event: 'roomAdd', room: room})\n  })\n\n  self.detailsView(function (details) {\n    self.id = details.data.id\n    self.fingerprint = details.data.fingerprint\n    self.rooms = details.data.rooms\n    callback(details)\n  })\n}\n\n// /////////////\n// MESSAGING //\n// /////////////\n\nActionheroClient.prototype.send = function (args, callback) {\n  // primus will buffer messages when not connected\n  var self = this\n  self.messageCount++\n  if (typeof callback === 'function') {\n    self.callbacks[self.messageCount] = callback\n  }\n  self.client.write(args)\n}\n\nActionheroClient.prototype.handleMessage = function (message) {\n  var self = this\n  self.emit('message', message)\n  if (message.context === 'response') {\n    if (typeof self.callbacks[message.messageCount] === 'function') {\n      self.callbacks[message.messageCount](message)\n    }\n    delete self.callbacks[message.messageCount]\n  } else if (message.context === 'user') {\n    self.emit('say', message)\n  } else if (message.context === 'alert') {\n    self.emit('alert', message)\n  } else if (message.welcome && message.context === 'api') {\n    self.welcomeMessage = message.welcome\n    self.emit('welcome', message)\n  } else if (message.context === 'api') {\n    self.emit('api', message)\n  }\n}\n\n// ///////////\n// ACTIONS //\n// ///////////\n\nActionheroClient.prototype.action = function (action, params, callback) {\n  if (!callback && typeof params === 'function') {\n    callback = params\n    params = null\n  }\n  if (!params) { params = {} }\n  params.action = action\n\n  if (this.state !== 'connected') {\n    this.actionWeb(params, callback)\n  } else {\n    this.actionWebSocket(params, callback)\n  }\n}\n\nActionheroClient.prototype.actionWeb = function (params, callback) {\n  var xmlhttp = new XMLHttpRequest()\n  xmlhttp.onreadystatechange = function () {\n    var response\n    if (xmlhttp.readyState === 4) {\n      if (xmlhttp.status === 200) {\n        response = JSON.parse(xmlhttp.responseText)\n      } else {\n        try {\n          response = JSON.parse(xmlhttp.responseText)\n        } catch (e) {\n          response = { error: {statusText: xmlhttp.statusText, responseText: xmlhttp.responseText} }\n        }\n      }\n      callback(response)\n    }\n  }\n\n  var method = (params.httpMethod || 'POST').toUpperCase()\n  var url = this.options.url + this.options.apiPath + '?action=' + params.action\n\n  if (method === 'GET') {\n    for (var param in params) {\n      if (~['action', 'httpMethod'].indexOf(param)) continue\n      url += '&' + param + '=' + params[param]\n    }\n  }\n\n  xmlhttp.open(method, url, true)\n  xmlhttp.setRequestHeader('Content-Type', 'application/json')\n  xmlhttp.send(JSON.stringify(params))\n}\n\nActionheroClient.prototype.actionWebSocket = function (params, callback) {\n  this.send({event: 'action', params: params}, callback)\n}\n\n// ////////////\n// COMMANDS //\n// ////////////\n\nActionheroClient.prototype.say = function (room, message, callback) {\n  this.send({event: 'say', room: room, message: message}, callback)\n}\n\nActionheroClient.prototype.file = function (file, callback) {\n  this.send({event: 'file', file: file}, callback)\n}\n\nActionheroClient.prototype.detailsView = function (callback) {\n  this.send({event: 'detailsView'}, callback)\n}\n\nActionheroClient.prototype.roomView = function (room, callback) {\n  this.send({event: 'roomView', room: room}, callback)\n}\n\nActionheroClient.prototype.roomAdd = function (room, callback) {\n  var self = this\n  self.send({event: 'roomAdd', room: room}, function (data) {\n    self.configure(function () {\n      if (typeof callback === 'function') { callback(data) }\n    })\n  })\n}\n\nActionheroClient.prototype.roomLeave = function (room, callback) {\n  var self = this\n  var index = self.rooms.indexOf(room)\n  if (index > -1) { self.rooms.splice(index, 1) }\n  this.send({event: 'roomLeave', room: room}, function (data) {\n    self.configure(function () {\n      if (typeof callback === 'function') { callback(data) }\n    })\n  })\n}\n\nActionheroClient.prototype.documentation = function (callback) {\n  this.send({event: 'documentation'}, callback)\n}\n\nActionheroClient.prototype.disconnect = function () {\n  this.state = 'disconnected'\n  this.client.end()\n  this.emit('disconnected')\n}\n\n// depricated lowercase name\nvar actionheroClient = ActionheroClient\n","/home/travis/build/npmtest/node-npmtest-actionhero/node_modules/actionhero/config/api.js":"'use strict'\n\nconst path = require('path')\n\nexports['default'] = {\n  general: function (api) {\n    const packageJSON = require(api.projectRoot + path.sep + 'package.json')\n\n    return {\n      apiVersion: packageJSON.version,\n      serverName: packageJSON.name,\n      // id can be set here, or it will be generated dynamically.\n      //  Be sure that every server you run has a unique ID (which will happen when generated dynamically)\n      //  id: 'myActionHeroServer',\n      // A unique token to your application that servers will use to authenticate to each other\n      serverToken: 'change-me',\n      // The welcome message seen by TCP and webSocket clients upon connection\n      welcomeMessage: 'Hello! Welcome to the actionhero api',\n      // the redis prefix for actionhero's cache objects\n      cachePrefix: 'actionhero:cache:',\n      // the redis prefix for actionhero's cache/lock objects\n      lockPrefix: 'actionhero:lock:',\n      // how long will a lock last before it exipres (ms)?\n      lockDuration: 1000 * 10, // 10 seconds\n      // Watch for changes in actions and tasks, and reload/restart them on the fly\n      developmentMode: true,\n      // How many pending actions can a single connection be working on\n      simultaneousActions: 5,\n      // allow connections to be created without remoteIp and remotePort (they will be set to 0)\n      enforceConnectionProperties: true,\n      // disables the whitelisting of client params\n      disableParamScrubbing: false,\n      // params you would like hidden from any logs\n      filteredParams: [],\n      // values that signify missing params\n      missingParamChecks: [null, '', undefined],\n      // The default filetype to server when a user requests a directory\n      directoryFileType: 'index.html',\n      // What log-level should we use for file requests?\n      fileRequestLogLevel: 'info',\n      // The default priority level given to middleware of all types (action, connection, say, and task)\n      defaultMiddlewarePriority: 100,\n      // Which channel to use on redis pub/sub for RPC communication\n      channel: 'actionhero',\n      // How long to wait for an RPC call before considering it a failure\n      rpcTimeout: 5000,\n      // configuration for your actionhero project structure\n      paths: {\n        'action': [path.join(__dirname, '/../actions')],\n        'task': [path.join(__dirname, '/../tasks')],\n        'public': [path.join(__dirname, '/../public')],\n        'pid': [path.join(__dirname, '/../pids')],\n        'log': [path.join(__dirname, '/../log')],\n        'server': [path.join(__dirname, '/../servers')],\n        'initializer': [path.join(__dirname, '/../initializers')],\n        'plugin': [path.join(__dirname, '/../node_modules')],\n        'locale': [path.join(__dirname, '/../locales')]\n      },\n      // hash containing chat rooms you wish to be created at server boot\n      startingChatRooms: {\n        // format is {roomName: {authKey, authValue}}\n        // 'secureRoom': {authorized: true},\n      }\n    }\n  }\n}\n\nexports.test = {\n  general: function (api) {\n    return {\n      id: 'test-server-' + process.pid,\n      serverToken: 'serverToken-' + process.pid,\n      developmentMode: true,\n      startingChatRooms: {\n        'defaultRoom': {},\n        'otherRoom': {}\n      },\n      paths: {\n        'locale': [require('os').tmpdir() + require('path').sep + 'locales']\n      },\n      rpcTimeout: 3000\n    }\n  }\n}\n\nexports.production = {\n  general: function (api) {\n    return {\n      fileRequestLogLevel: 'debug',\n      developmentMode: false\n    }\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-actionhero/node_modules/actionhero/config/errors.js":"'use strict'\n\n// error messages can be strings of objects\nexports['default'] = {\n  errors: function (api) {\n    return {\n      '_toExpand': false,\n\n      // ///////////////\n      // SERIALIZERS //\n      // ///////////////\n\n      serializers: {\n        servers: {\n          web: function (error) {\n            if (error.message) {\n              return String(error.message)\n            } else {\n              return error\n            }\n          },\n          websocket: function (error) {\n            if (error.message) {\n              return String(error.message)\n            } else {\n              return error\n            }\n          },\n          socket: function (error) {\n            if (error.message) {\n              return String(error.message)\n            } else {\n              return error\n            }\n          },\n          specHelper: function (error) {\n            if (error.message) {\n              return 'Error: ' + String(error.message)\n            } else {\n              return error\n            }\n          }\n        }\n      },\n\n      // ///////////\n      // ACTIONS //\n      // ///////////\n\n      // When a params for an action is invalid\n      invalidParams: function (data, validationErrors) {\n        if (validationErrors.length >= 0) { return validationErrors[0] }\n        return 'validation error'\n      },\n\n      // When a required param for an action is not provided\n      missingParams: function (data, missingParams) {\n        return data.connection.localize(['%s is a required parameter for this action', missingParams[0]])\n      },\n\n      // user requested an unknown action\n      unknownAction: function (data) {\n        return data.connection.localize('unknown action or invalid apiVersion')\n      },\n\n      // action not useable by this client/server type\n      unsupportedServerType: function (data) {\n        return data.connection.localize(['this action does not support the %s connection type', data.connection.type])\n      },\n\n      // action failed because server is mid-shutdown\n      serverShuttingDown: function (data) {\n        return data.connection.localize('the server is shutting down')\n      },\n\n      // action failed because this client already has too many pending acitons\n      // limit defined in api.config.general.simultaneousActions\n      tooManyPendingActions: function (data) {\n        return data.connection.localize('you have too many pending requests')\n      },\n\n      dataLengthTooLarge: function (maxLength, receivedLength) {\n        return api.i18n.localize(['data length is too big (%u received/%u max)', maxLength, receivedLength])\n      },\n\n      // ///////////////\n      // FILE SERVER //\n      // ///////////////\n\n      // The body message to accompany 404 (file not found) errors regarding flat files\n      // You may want to load in the contnet of 404.html or similar\n      fileNotFound: function (connection) {\n        return connection.localize(['That file is not found'])\n      },\n\n      // user didn't request a file\n      fileNotProvided: function (connection) {\n        return connection.localize('file is a required param to send a file')\n      },\n\n      // something went wrong trying to read the file\n      fileReadError: function (connection, error) {\n        return connection.localize(['error reading file: %s', String(error)])\n      },\n\n      // ///////////////\n      // CONNECTIONS //\n      // ///////////////\n\n      verbNotFound: function (connection, verb) {\n        return connection.localize(['I do not know know to perform this verb (%s)', verb])\n      },\n\n      verbNotAllowed: function (connection, verb) {\n        return connection.localize(['verb not found or not allowed (%s)', verb])\n      },\n\n      connectionRoomAndMessage: function (connection) {\n        return connection.localize('both room and message are required')\n      },\n\n      connectionNotInRoom: function (connection, room) {\n        return connection.localize(['connection not in this room (%s)', room])\n      },\n\n      connectionAlreadyInRoom: function (connection, room) {\n        return connection.localize(['connection already in this room (%s)', room])\n      },\n\n      connectionRoomHasBeenDeleted: function (room) {\n        return api.i18n.localize('this room has been deleted')\n      },\n\n      connectionRoomNotExist: function (room) {\n        return api.i18n.localize('room does not exist')\n      },\n\n      connectionRoomExists: function (room) {\n        return api.i18n.localize('room exists')\n      },\n\n      connectionRoomRequired: function (room) {\n        return api.i18n.localize('a room is required')\n      }\n\n    }\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-actionhero/node_modules/actionhero/config/i18n.js":"exports['default'] = {\n  i18n: function (api) {\n    return {\n      // visit https://github.com/mashpie/i18n-node to see all configuration options\n      // locale path can be configired from within ./config/api.js\n      locales: ['en'],\n\n      // how would you like your lanaguages to fall back if a translation string is missing?\n      fallbacks: {\n        // 'es': 'en'\n      },\n\n      updateFiles: true,\n\n      // this will configure logging and error messages in the log(s)\n      defaultLocale: 'en',\n\n      // the name of the method by which to determine the connection's locale\n      // by default, every request will be in the 'en' locale\n      // this method will be called witin the localiazation middleware on all requests\n      determineConnectionLocale: 'api.i18n.determineConnectionLocale'\n    }\n  }\n}\n\nexports.staging = {\n  i18n: function () {\n    return {\n      updateFiles: false\n    }\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-actionhero/node_modules/actionhero/config/logger.js":"'use strict'\n\nconst fs = require('fs')\nconst cluster = require('cluster')\n\nexports['default'] = {\n  logger: function (api) {\n    let logger = {transports: []}\n\n    // console logger\n    if (cluster.isMaster) {\n      logger.transports.push(function (api, winston) {\n        return new (winston.transports.Console)({\n          colorize: true,\n          level: 'info',\n          timestamp: function () { return api.id + ' @ ' + new Date().toISOString() }\n        })\n      })\n    }\n\n    // file logger\n    logger.transports.push(function (api, winston) {\n      if (api.config.general.paths.log.length === 1) {\n        const logDirectory = api.config.general.paths.log[0]\n        try {\n          fs.mkdirSync(logDirectory)\n        } catch (e) {\n          if (e.code !== 'EEXIST') {\n            throw (new Error('Cannot create log directory @ ' + logDirectory))\n          }\n        }\n      }\n\n      return new (winston.transports.File)({\n        filename: api.config.general.paths.log[0] + '/' + api.pids.title + '.log',\n        level: 'info',\n        timestamp: function () { return api.id + ' @ ' + new Date().toISOString() }\n      })\n    })\n\n    // the maximum length of param to log (we will truncate)\n    logger.maxLogStringLength = 100\n\n    // should system logs (api.log) be localized?\n    logger.localizeLogMessages = false\n\n    // you can optionally set custom log levels\n    // logger.levels = {good: 0, bad: 1};\n\n    // you can optionally set custom log colors\n    // logger.colors = {good: 'blue', bad: 'red'};\n\n    return logger\n  }\n}\n\nexports.test = {\n  logger: function (api) {\n    return {\n      transports: null\n    }\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-actionhero/node_modules/actionhero/config/redis.js":"const host = process.env.REDIS_HOST || '127.0.0.1'\nconst port = process.env.REDIS_PORT || 6379\nconst db = process.env.REDIS_DB || 0\nconst password = process.env.REDIS_PASSWORD || null\nconst maxBackoff = 1000\n\nexports['default'] = {\n  redis: function (api) {\n    // konstructor: The redis client constructor method\n    // args: The arguments to pass to the constructor\n    // buildNew: is it `new konstructor()` or just `konstructor()`?\n\n    function retryStrategy (times) {\n      if (times === 1) {\n        api.log('Unable to connect to Redis - please check your Redis config!', 'error')\n        return 5000\n      }\n      return Math.min(times * 50, maxBackoff)\n    }\n\n    if (process.env.FAKEREDIS === 'false' || process.env.REDIS_HOST !== undefined) {\n      return {\n        '_toExpand': false,\n        client: {\n          konstructor: require('ioredis'),\n          args: [{ port: port, host: host, password: password, db: db, retryStrategy: retryStrategy }],\n          buildNew: true\n        },\n        subscriber: {\n          konstructor: require('ioredis'),\n          args: [{ port: port, host: host, password: password, db: db, retryStrategy: retryStrategy }],\n          buildNew: true\n        },\n        tasks: {\n          konstructor: require('ioredis'),\n          args: [{ port: port, host: host, password: password, db: db, retryStrategy: retryStrategy }],\n          buildNew: true\n        }\n      }\n    } else {\n      return {\n        '_toExpand': false,\n        client: {\n          konstructor: require('fakeredis').createClient,\n          args: [port, host, {fast: true}],\n          buildNew: false\n        },\n        subscriber: {\n          konstructor: require('fakeredis').createClient,\n          args: [port, host, {fast: true}],\n          buildNew: false\n        },\n        tasks: {\n          konstructor: require('fakeredis').createClient,\n          args: [port, host, {fast: true}],\n          buildNew: false\n        }\n      }\n    }\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-actionhero/node_modules/actionhero/config/routes.js":"exports['default'] = {\n  routes: function (api) {\n    return {\n\n      /* ---------------------\n      routes.js\n\n      For web clients (http and https) you can define an optional RESTful mapping to help route requests to actions.\n      If the client doesn't specify and action in a param, and the base route isn't a named action, the action will attempt to be discerned from this routes.js file.\n\n      Learn more here: http://www.actionherojs.com/docs/#routes\n\n      examples:\n\n      get: [\n        { path: '/users', action: 'usersList' }, // (GET) /api/users\n        { path: '/search/:term/limit/:limit/offset/:offset', action: 'search' }, // (GET) /api/search/car/limit/10/offset/100\n      ],\n\n      post: [\n        { path: '/login/:userID(^\\\\d{3}$)', action: 'login' } // (POST) /api/login/123\n      ],\n\n      all: [\n        { path: '/user/:userID', action: 'user', matchTrailingPathParts: true } // (*) /api/user/123, api/user/123/stuff\n      ]\n\n      ---------------------- */\n\n    }\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-actionhero/node_modules/actionhero/config/tasks.js":"exports['default'] = {\n  tasks: function (api) {\n    return {\n      // Should this node run a scheduler to promote delayed tasks?\n      scheduler: false,\n      // what queues should the taskProcessors work?\n      queues: ['*'],\n      // Logging levels of task workers\n      workerLogging: {\n        failure: 'error', // task failure\n        success: 'info',  // task success\n        start: 'info',\n        end: 'info',\n        cleaning_worker: 'info',\n        poll: 'debug',\n        job: 'debug',\n        pause: 'debug',\n        internalError: 'error',\n        multiWorkerAction: 'debug'\n      },\n      // Logging levels of the task scheduler\n      schedulerLogging: {\n        start: 'info',\n        end: 'info',\n        poll: 'debug',\n        enqueue: 'debug',\n        reEnqueue: 'debug',\n        working_timestamp: 'debug',\n        transferred_job: 'debug'\n      },\n      // how long to sleep between jobs / scheduler checks\n      timeout: 5000,\n      // at minimum, how many parallel taskProcessors should this node spawn?\n      // (have number > 0 to enable, and < 1 to disable)\n      minTaskProcessors: 0,\n      // at maximum, how many parallel taskProcessors should this node spawn?\n      maxTaskProcessors: 0,\n      // how often should we check the event loop to spawn more taskProcessors?\n      checkTimeout: 500,\n      // how many ms would constitue an event loop delay to halt taskProcessors spawning?\n      maxEventLoopDelay: 5,\n      // When we kill off a taskProcessor, should we disconnect that local redis connection?\n      toDisconnectProcessors: true,\n      // Customize Resque primitives, replace null with required replacement.\n      resque_overrides: {\n        queue: null,\n        multiWorker: null,\n        scheduler: null\n      }\n    }\n  }\n}\n\nexports.test = {\n  tasks: function (api) {\n    return {\n      timeout: 100,\n      checkTimeout: 50\n    }\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-actionhero/node_modules/actionhero/initializers/actionProcessor.js":"'use strict'\n\nconst async = require('async')\n\nmodule.exports = {\n  loadPriority: 430,\n  initialize: function (api, next) {\n    const prepareStringMethod = function (method) {\n      const cmdParts = method.split('.')\n      const cmd = cmdParts.shift()\n      if (cmd !== 'api') { throw new Error('cannot operate on a method outside of the api object') }\n      return api.utils.stringToHash(cmdParts.join('.'))\n    }\n\n    api.ActionProcessor = function (connection, callback) {\n      if (!connection) {\n        throw new Error('data.connection is required')\n      }\n\n      this.connection = connection\n      this.action = null\n      this.toProcess = true\n      this.toRender = true\n      this.messageCount = connection.messageCount\n      this.params = connection.params\n      this.callback = callback\n      this.missingParams = []\n      this.validatorErrors = []\n      this.actionStartTime = null\n      this.actionTemplate = null\n      this.working = false\n      this.response = {}\n      this.duration = null\n      this.actionStatus = null\n    }\n\n    api.ActionProcessor.prototype.incrementTotalActions = function (count) {\n      if (!count) { count = 1 }\n      this.connection.totalActions = this.connection.totalActions + count\n    }\n\n    api.ActionProcessor.prototype.incrementPendingActions = function (count) {\n      if (!count) { count = 1 }\n      this.connection.pendingActions = this.connection.pendingActions + count\n    }\n\n    api.ActionProcessor.prototype.getPendingActionCount = function () {\n      return this.connection.pendingActions\n    }\n\n    api.ActionProcessor.prototype.completeAction = function (status) {\n      let error = null\n      this.actionStatus = String(status)\n\n      if (status instanceof Error) {\n        error = status\n      } else if (status === 'server_shutting_down') {\n        error = api.config.errors.serverShuttingDown(this)\n      } else if (status === 'too_many_requests') {\n        error = api.config.errors.tooManyPendingActions(this)\n      } else if (status === 'unknown_action') {\n        error = api.config.errors.unknownAction(this)\n      } else if (status === 'unsupported_server_type') {\n        error = api.config.errors.unsupportedServerType(this)\n      } else if (status === 'missing_params') {\n        error = api.config.errors.missingParams(this, this.missingParams)\n      } else if (status === 'validator_errors') {\n        error = api.config.errors.invalidParams(this, this.validatorErrors)\n      } else if (status) {\n        error = status\n      }\n\n      if (error && typeof error === 'string') {\n        error = new Error(error)\n      }\n\n      if (error && !this.response.error) {\n        if (typeof this.response === 'string' || Array.isArray(this.response)) {\n          this.response = error.toString()\n        } else {\n          this.response.error = error\n        }\n      }\n\n      this.incrementPendingActions(-1)\n      this.duration = new Date().getTime() - this.actionStartTime\n\n      process.nextTick(() => {\n        if (typeof this.callback === 'function') {\n          this.callback(this)\n        }\n      })\n\n      this.working = false\n      this.logAction(error)\n    }\n\n    api.ActionProcessor.prototype.logAction = function (error) {\n      // logging\n      let logLevel = 'info'\n      if (this.actionTemplate && this.actionTemplate.logLevel) {\n        logLevel = this.actionTemplate.logLevel\n      }\n\n      let filteredParams = {}\n      for (let i in this.params) {\n        if (api.config.general.filteredParams && api.config.general.filteredParams.indexOf(i) >= 0) {\n          filteredParams[i] = '[FILTERED]'\n        } else if (typeof this.params[i] === 'string') {\n          filteredParams[i] = this.params[i].substring(0, api.config.logger.maxLogStringLength)\n        } else {\n          filteredParams[i] = this.params[i]\n        }\n      }\n\n      const logLine = {\n        to: this.connection.remoteIP,\n        action: this.action,\n        params: JSON.stringify(filteredParams),\n        duration: this.duration\n      }\n\n      if (error) {\n        if (error instanceof Error) {\n          logLine.error = String(error)\n        } else {\n          try {\n            logLine.error = JSON.stringify(error)\n          } catch (e) {\n            logLine.error = String(error)\n          }\n        }\n      }\n\n      api.log(['[ action @ %s ]', this.connection.type], logLevel, logLine)\n    }\n\n    api.ActionProcessor.prototype.preProcessAction = function (callback) {\n      let processors = []\n      let processorNames = api.actions.globalMiddleware.slice(0)\n\n      if (this.actionTemplate.middleware) {\n        this.actionTemplate.middleware.forEach(function (m) { processorNames.push(m) })\n      }\n\n      processorNames.forEach((name) => {\n        if (typeof api.actions.middleware[name].preProcessor === 'function') {\n          processors.push((next) => { api.actions.middleware[name].preProcessor(this, next) })\n        }\n      })\n\n      async.series(processors, callback)\n    }\n\n    api.ActionProcessor.prototype.postProcessAction = function (callback) {\n      let processors = []\n      let processorNames = api.actions.globalMiddleware.slice(0)\n\n      if (this.actionTemplate.middleware) {\n        this.actionTemplate.middleware.forEach((m) => { processorNames.push(m) })\n      }\n\n      processorNames.forEach((name) => {\n        if (typeof api.actions.middleware[name].postProcessor === 'function') {\n          processors.push((next) => { api.actions.middleware[name].postProcessor(this, next) })\n        }\n      })\n\n      async.series(processors, callback)\n    }\n\n    api.ActionProcessor.prototype.reduceParams = function (schemaKey) {\n      let inputs = this.actionTemplate.inputs || {}\n      let params = this.params\n      if (schemaKey) {\n        inputs = this.actionTemplate.inputs[schemaKey].schema\n        params = this.params[schemaKey]\n      }\n\n      const inputNames = Object.keys(inputs) || []\n      if (api.config.general.disableParamScrubbing !== true) {\n        for (let p in params) {\n          if (api.params.globalSafeParams.indexOf(p) < 0 && inputNames.indexOf(p) < 0) {\n            delete params[p]\n          }\n        }\n      }\n    }\n\n    api.ActionProcessor.prototype.validateParam = function (props, params, key, schemaKey) {\n      // default\n      if (params[key] === undefined && props['default'] !== undefined) {\n        if (typeof props['default'] === 'function') {\n          params[key] = props['default'].call(api, params[key], this)\n        } else {\n          params[key] = props['default']\n        }\n      }\n\n      // formatter\n      if (params[key] !== undefined && props.formatter !== undefined) {\n        if (!Array.isArray(props.formatter)) { props.formatter = [props.formatter] }\n\n        props.formatter.forEach((formatter) => {\n          if (typeof formatter === 'function') {\n            params[key] = formatter.call(api, params[key], this)\n          } else {\n            const method = prepareStringMethod(formatter)\n            params[key] = method.call(api, params[key], this)\n          }\n        })\n      }\n\n      // validator\n      if (params[key] !== undefined && props.validator !== undefined) {\n        if (!Array.isArray(props.validator)) { props.validator = [props.validator] }\n\n        props.validator.forEach((validator) => {\n          let validatorResponse\n          if (typeof validator === 'function') {\n            validatorResponse = validator.call(api, params[key], this)\n          } else {\n            const method = prepareStringMethod(validator)\n            validatorResponse = method.call(api, params[key], this)\n          }\n          if (validatorResponse !== true) { this.validatorErrors.push(validatorResponse) }\n        })\n      }\n\n      // required\n      if (props.required === true) {\n        if (api.config.general.missingParamChecks.indexOf(params[key]) >= 0) {\n          let missingKey = key\n          if (schemaKey) {\n            missingKey = `${schemaKey}.${missingKey}`\n          }\n          this.missingParams.push(missingKey)\n        }\n      }\n    }\n\n    api.ActionProcessor.prototype.validateParams = function (schemaKey) {\n      let inputs = this.actionTemplate.inputs || {}\n      let params = this.params\n      if (schemaKey) {\n        inputs = this.actionTemplate.inputs[schemaKey].schema\n        params = this.params[schemaKey]\n      }\n\n      Object.keys(inputs).forEach((key) => {\n        const props = inputs[key]\n        this.validateParam(props, params, key, schemaKey)\n\n        if (props.schema && params[key]) {\n          this.reduceParams(key)\n          this.validateParams(key)\n        }\n      })\n    }\n\n    api.ActionProcessor.prototype.processAction = function () {\n      this.actionStartTime = new Date().getTime()\n      this.working = true\n      this.incrementTotalActions()\n      this.incrementPendingActions()\n      this.action = this.params.action\n\n      if (api.actions.versions[this.action]) {\n        if (!this.params.apiVersion) {\n          this.params.apiVersion = api.actions.versions[this.action][api.actions.versions[this.action].length - 1]\n        }\n        this.actionTemplate = api.actions.actions[this.action][this.params.apiVersion]\n      }\n\n      if (api.running !== true) {\n        this.completeAction('server_shutting_down')\n      } else if (this.getPendingActionCount(this.connection) > api.config.general.simultaneousActions) {\n        this.completeAction('too_many_requests')\n      } else if (!this.action || !this.actionTemplate) {\n        this.completeAction('unknown_action')\n      } else if (this.actionTemplate.blockedConnectionTypes && this.actionTemplate.blockedConnectionTypes.indexOf(this.connection.type) >= 0) {\n        this.completeAction('unsupported_server_type')\n      } else {\n        this.runAction()\n      }\n    }\n\n    api.ActionProcessor.prototype.runAction = function () {\n      this.preProcessAction((error) => {\n        this.reduceParams()\n        this.validateParams()\n\n        if (error) {\n          this.completeAction(error)\n        } else if (this.missingParams.length > 0) {\n          this.completeAction('missing_params')\n        } else if (this.validatorErrors.length > 0) {\n          this.completeAction('validator_errors')\n        } else if (this.toProcess === true && !error) {\n          this.actionTemplate.run(api, this, (error) => {\n            if (error) {\n              this.completeAction(error)\n            } else {\n              this.postProcessAction((error) => {\n                this.completeAction(error)\n              })\n            }\n          })\n        } else {\n          this.completeAction()\n        }\n      })\n    }\n\n    next()\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-actionhero/node_modules/actionhero/initializers/actions.js":"'use strict'\n\nmodule.exports = {\n  loadPriority: 410,\n  initialize: function (api, next) {\n    api.actions = {}\n    api.actions.actions = {}\n    api.actions.versions = {}\n\n    api.actions.middleware = {}\n    api.actions.globalMiddleware = []\n\n    api.actions.addMiddleware = function (data) {\n      if (!data.name) { throw new Error('middleware.name is required') }\n      if (!data.priority) { data.priority = api.config.general.defaultMiddlewarePriority }\n      data.priority = Number(data.priority)\n      api.actions.middleware[data.name] = data\n      if (data.global === true) {\n        api.actions.globalMiddleware.push(data.name)\n        api.utils.sortGlobalMiddleware(api.actions.globalMiddleware, api.actions.middleware)\n      }\n    }\n\n    api.actions.validateAction = function (action) {\n      const fail = (msg) => {\n        return next(new Error(msg))\n      }\n\n      if (action.inputs === undefined) {\n        action.inputs = {}\n      }\n\n      if (typeof action.name !== 'string' || action.name.length < 1) {\n        fail('an action is missing \\'action.name\\'')\n        return false\n      } else if (typeof action.description !== 'string' || action.description.length < 1) {\n        fail('Action ' + action.name + ' is missing \\'action.description\\'')\n        return false\n      } else if (typeof action.run !== 'function') {\n        fail('Action ' + action.name + ' has no run method')\n        return false\n      } else if (api.connections !== null && api.connections.allowedVerbs.indexOf(action.name) >= 0) {\n        fail(action.name + ' is a reserved verb for connections. choose a new name')\n        return false\n      } else {\n        return true\n      }\n    }\n\n    api.actions.loadFile = function (fullFilePath, reload) {\n      if (reload === null) { reload = false }\n\n      const loadMessage = (action) => {\n        if (reload) {\n          api.log(['action reloaded: %s @ v%s, %s', action.name, action.version, fullFilePath], 'debug')\n        } else {\n          api.log(['action loaded: %s @ v%s, %s', action.name, action.version, fullFilePath], 'debug')\n        }\n      }\n\n      api.watchFileAndAct(fullFilePath, function () {\n        api.actions.loadFile(fullFilePath, true)\n        api.params.buildPostVariables()\n        api.routes.loadRoutes()\n      })\n\n      let action\n\n      try {\n        const collection = require(fullFilePath)\n        for (let i in collection) {\n          action = collection[i]\n          if (action.version === null || action.version === undefined) { action.version = 1.0 }\n          if (api.actions.actions[action.name] === null || api.actions.actions[action.name] === undefined) {\n            api.actions.actions[action.name] = {}\n          }\n          api.actions.actions[action.name][action.version] = action\n          if (api.actions.versions[action.name] === null || api.actions.versions[action.name] === undefined) {\n            api.actions.versions[action.name] = []\n          }\n          api.actions.versions[action.name].push(action.version)\n          api.actions.versions[action.name].sort()\n          api.actions.validateAction(api.actions.actions[action.name][action.version])\n          loadMessage(action)\n        }\n      } catch (error) {\n        try {\n          api.exceptionHandlers.loader(fullFilePath, error)\n          delete api.actions.actions[action.name][action.version]\n        } catch (err2) {\n          throw error\n        }\n      }\n    }\n\n    api.config.general.paths.action.forEach(function (p) {\n      api.utils.recursiveDirectoryGlob(p).forEach(function (f) {\n        api.actions.loadFile(f)\n      })\n    })\n\n    next()\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-actionhero/node_modules/actionhero/initializers/cache.js":"'use strict'\n\nconst fs = require('fs')\nconst async = require('async')\n\nmodule.exports = {\n  startPriority: 300,\n  loadPriority: 300,\n  initialize: function (api, next) {\n    api.cache = {}\n    api.cache.redisPrefix = api.config.general.cachePrefix\n    api.cache.lockPrefix = api.config.general.lockPrefix\n    api.cache.lockDuration = api.config.general.lockDuration\n    api.cache.lockName = api.id\n    api.cache.lockRetry = 100\n\n    const redis = api.redis.clients.client\n\n    api.cache.keys = function (callback) {\n      redis.keys(api.cache.redisPrefix + '*', callback)\n    }\n\n    api.cache.locks = function (callback) {\n      redis.keys(api.cache.lockPrefix + '*', callback)\n    }\n\n    api.cache.size = function (callback) {\n      api.cache.keys((error, keys) => {\n        let length = 0\n        if (keys) { length = keys.length }\n        callback(error, length)\n      })\n    }\n\n    api.cache.clear = function (callback) {\n      api.cache.keys((error, keys) => {\n        if (error && typeof callback === 'function') { return callback(error) }\n        let jobs = []\n        keys.forEach((key) => {\n          jobs.push((done) => { redis.del(key, done) })\n        })\n\n        async.parallel(jobs, (error) => {\n          if (typeof callback === 'function') { return callback(error) }\n        })\n      })\n    }\n\n    api.cache.dumpWrite = function (file, callback) {\n      let data = {}\n      api.cache.keys((error, keys) => {\n        if (error && typeof callback === 'function') { return callback(error) }\n        let jobs = []\n        keys.forEach((key) => {\n          jobs.push((done) => {\n            redis.get(key, (error, content) => {\n              if (error) { return done(error) }\n              data[key] = content\n              return done()\n            })\n          })\n        })\n\n        async.parallel(jobs, function (error) {\n          if (error) {\n            if (typeof callback === 'function') { return callback(error) }\n          } else {\n            fs.writeFileSync(file, JSON.stringify(data))\n            if (typeof callback === 'function') { return callback(null, keys.length) }\n          }\n        })\n      })\n    }\n\n    api.cache.dumpRead = function (file, callback) {\n      api.cache.clear((error) => {\n        if (error) {\n          if (typeof callback === 'function') { return callback(error) }\n        } else {\n          let jobs = []\n          let data\n          try {\n            data = JSON.parse(fs.readFileSync(file))\n          } catch (error) { return callback(error) }\n\n          Object.keys(data).forEach((key) => {\n            let content = data[key]\n            jobs.push(function (done) { api.cache.saveDumpedElement(key, content, done) })\n          })\n\n          async.series(jobs, (error) => {\n            if (typeof callback === 'function') { return callback(error, Object.keys(data).length) }\n          })\n        }\n      })\n    }\n\n    api.cache.saveDumpedElement = function (key, content, callback) {\n      let parsedContent\n      try {\n        parsedContent = JSON.parse(content)\n      } catch (error) { return callback(error) }\n\n      redis.set(key, content, (error) => {\n        if (error) { return callback(error) } else if (parsedContent.expireTimestamp) {\n          const expireTimeSeconds = Math.ceil((parsedContent.expireTimestamp - new Date().getTime()) / 1000)\n          redis.expire(key, expireTimeSeconds, () => {\n            return callback(error)\n          })\n        } else {\n          return callback()\n        }\n      })\n    }\n\n    api.cache.load = function (key, options, callback) {\n      // optons: options.expireTimeMS, options.retry\n      if (typeof options === 'function') {\n        callback = options\n        options = {}\n      }\n\n      redis.get(api.cache.redisPrefix + key, function (error, cacheObj) {\n        if (error) { api.log(error, 'error') }\n        try { cacheObj = JSON.parse(cacheObj) } catch (e) {}\n        if (!cacheObj) {\n          if (typeof callback === 'function') {\n            return callback(new Error(api.i18n.localize('Object not found')), null, null, null, null)\n          }\n        } else if (cacheObj.expireTimestamp >= new Date().getTime() || cacheObj.expireTimestamp === null) {\n          const lastReadAt = cacheObj.readAt\n          let expireTimeSeconds\n          cacheObj.readAt = new Date().getTime()\n          if (cacheObj.expireTimestamp) {\n            if (options.expireTimeMS) {\n              cacheObj.expireTimestamp = new Date().getTime() + options.expireTimeMS\n              expireTimeSeconds = Math.ceil(options.expireTimeMS / 1000)\n            } else {\n              expireTimeSeconds = Math.floor((cacheObj.expireTimestamp - new Date().getTime()) / 1000)\n            }\n          }\n\n          api.cache.checkLock(key, options.retry, function (error, lockOk) {\n            if (error || lockOk !== true) {\n              if (typeof callback === 'function') { return callback(new Error(api.i18n.localize('Object Locked'))) }\n            } else {\n              redis.set(api.cache.redisPrefix + key, JSON.stringify(cacheObj), (error) => {\n                if (typeof callback === 'function' && typeof expireTimeSeconds !== 'number') {\n                  return callback(error, cacheObj.value, cacheObj.expireTimestamp, cacheObj.createdAt, lastReadAt)\n                } else {\n                  redis.expire(api.cache.redisPrefix + key, expireTimeSeconds, (error) => {\n                    if (typeof callback === 'function') { return callback(error, cacheObj.value, cacheObj.expireTimestamp, cacheObj.createdAt, lastReadAt) }\n                  })\n                }\n              })\n            }\n          })\n        } else {\n          if (typeof callback === 'function') {\n            return callback(new Error(api.i18n.localize('Object Expired')))\n          }\n        }\n      })\n    }\n\n    api.cache.destroy = function (key, callback) {\n      api.cache.checkLock(key, null, (error, lockOk) => {\n        if (error || lockOk !== true) {\n          if (typeof callback === 'function') { callback(new Error(api.i18n.localize('Object Locked'))) }\n        } else {\n          redis.del(api.cache.redisPrefix + key, (error, count) => {\n            if (error) { api.log(error, 'error') }\n            let resp = true\n            if (count !== 1) { resp = false }\n            if (typeof callback === 'function') { callback(error, resp) }\n          })\n        }\n      })\n    }\n\n    api.cache.save = function (key, value, expireTimeMS, callback) {\n      if (typeof expireTimeMS === 'function' && typeof callback === 'undefined') {\n        callback = expireTimeMS\n        expireTimeMS = null\n      }\n\n      let expireTimeSeconds = null\n      let expireTimestamp = null\n      if (expireTimeMS !== null) {\n        expireTimeSeconds = Math.ceil(expireTimeMS / 1000)\n        expireTimestamp = new Date().getTime() + expireTimeMS\n      }\n\n      const cacheObj = {\n        value: value,\n        expireTimestamp: expireTimestamp,\n        createdAt: new Date().getTime(),\n        readAt: null\n      }\n\n      api.cache.checkLock(key, null, function (error, lockOk) {\n        if (error || lockOk !== true) {\n          if (typeof callback === 'function') { return callback(new Error(api.i18n.localize('Object Locked'))) }\n        } else {\n          redis.set(api.cache.redisPrefix + key, JSON.stringify(cacheObj), (error) => {\n            if (!error && expireTimeSeconds) {\n              redis.expire(api.cache.redisPrefix + key, expireTimeSeconds, (error) => {\n                if (typeof callback === 'function') { return callback(error, true) }\n              })\n            } else {\n              if (typeof callback === 'function') { return callback(error, true) }\n            }\n          })\n        }\n      })\n    }\n\n    api.cache.push = function (key, item, callback) {\n      let object = JSON.stringify({data: item})\n      redis.rpush(api.cache.redisPrefix + key, object, (error) => {\n        if (typeof callback === 'function') { callback(error) }\n      })\n    }\n\n    api.cache.pop = function (key, callback) {\n      redis.lpop(api.cache.redisPrefix + key, (error, object) => {\n        if (error) { return callback(error) }\n        if (!object) { return callback() }\n        let item\n        try {\n          item = JSON.parse(object)\n        } catch (error) { return callback(error) }\n        return callback(null, item.data)\n      })\n    }\n\n    api.cache.listLength = function (key, callback) {\n      redis.llen(api.cache.redisPrefix + key, callback)\n    }\n\n    api.cache.lock = function (key, expireTimeMS, callback) {\n      if (typeof expireTimeMS === 'function' && callback === null) {\n        callback = expireTimeMS\n        expireTimeMS = null\n      }\n      if (expireTimeMS === null) {\n        expireTimeMS = api.cache.lockDuration\n      }\n\n      api.cache.checkLock(key, null, (error, lockOk) => {\n        if (error || lockOk !== true) {\n          return callback(error, false)\n        } else {\n          redis.setnx(api.cache.lockPrefix + key, api.cache.lockName, (error, result) => {\n            if (error) {\n              return callback(error)\n            } else {\n              if (!result) { // value was already set, so we cannot obtain the lock\n                return callback(null, false)\n              }\n              redis.expire(api.cache.lockPrefix + key, Math.ceil(expireTimeMS / 1000), (error) => {\n                lockOk = true\n                if (error) { lockOk = false }\n                return callback(error, lockOk)\n              })\n            }\n          })\n        }\n      })\n    }\n\n    api.cache.unlock = function (key, callback) {\n      api.cache.checkLock(key, null, (error, lockOk) => {\n        if (error || lockOk !== true) {\n          return callback(error, false)\n        } else {\n          redis.del(api.cache.lockPrefix + key, (error) => {\n            lockOk = true\n            if (error) { lockOk = false }\n            return callback(error, lockOk)\n          })\n        }\n      })\n    }\n\n    api.cache.checkLock = function (key, retry, callback, startTime) {\n      if (startTime === null) { startTime = new Date().getTime() }\n\n      redis.get(api.cache.lockPrefix + key, (error, lockedBy) => {\n        if (error) {\n          return callback(error, false)\n        } else if (lockedBy === api.cache.lockName || lockedBy === null) {\n          return callback(null, true)\n        } else {\n          const delta = new Date().getTime() - startTime\n          if (retry === null || retry === false || delta > retry) {\n            return callback(null, false)\n          } else {\n            return setTimeout(() => {\n              api.cache.checkLock(key, retry, callback, startTime)\n            }, api.cache.lockRetry)\n          }\n        }\n      })\n    }\n\n    next()\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-actionhero/node_modules/actionhero/initializers/chatRoom.js":"'use strict'\n\nconst async = require('async')\n\nmodule.exports = {\n  startPriority: 200,\n  loadPriority: 520,\n  initialize: function (api, next) {\n    api.chatRoom = {}\n    api.chatRoom.keys = {\n      rooms: 'actionhero:chatRoom:rooms',\n      members: 'actionhero:chatRoom:members:'\n    }\n    api.chatRoom.messageChannel = '/actionhero/chat/chat'\n\n    api.chatRoom.middleware = {}\n    api.chatRoom.globalMiddleware = []\n\n    api.chatRoom.addMiddleware = function (data) {\n      if (!data.name) { throw new Error('middleware.name is required') }\n      if (!data.priority) { data.priority = api.config.general.defaultMiddlewarePriority }\n      data.priority = Number(data.priority)\n      api.chatRoom.middleware[data.name] = data\n\n      api.chatRoom.globalMiddleware.push(data.name)\n      api.chatRoom.globalMiddleware.sort((a, b) => {\n        if (api.chatRoom.middleware[a].priority > api.chatRoom.middleware[b].priority) {\n          return 1\n        } else {\n          return -1\n        }\n      })\n    }\n\n    api.chatRoom.broadcast = function (connection, room, message, callback) {\n      if (!room || room.length === 0 || message === null || message.length === 0) {\n        if (typeof callback === 'function') { process.nextTick(() => { callback(api.config.errors.connectionRoomAndMessage(connection)) }) }\n      } else if (connection.rooms === undefined || connection.rooms.indexOf(room) > -1) {\n        if (connection.id === undefined) { connection.id = 0 }\n        const payload = {\n          messageType: 'chat',\n          serverToken: api.config.general.serverToken,\n          serverId: api.id,\n          message: message,\n          sentAt: new Date().getTime(),\n          connection: {\n            id: connection.id,\n            room: room\n          }\n        }\n        const messagePayload = api.chatRoom.generateMessagePayload(payload)\n\n        api.chatRoom.handleCallbacks(connection, messagePayload.room, 'onSayReceive', messagePayload, (error, newPayload) => {\n          if (error) {\n            if (typeof callback === 'function') { process.nextTick(() => { callback(error) }) }\n          } else {\n            const payloadToSend = {\n              messageType: 'chat',\n              serverToken: api.config.general.serverToken,\n              serverId: api.id,\n              message: newPayload.message,\n              sentAt: newPayload.sentAt,\n              connection: {\n                id: newPayload.from,\n                room: newPayload.room\n              }\n            }\n            api.redis.publish(payloadToSend)\n            if (typeof callback === 'function') { process.nextTick(() => { callback(null) }) }\n          }\n        })\n      } else {\n        if (typeof callback === 'function') { process.nextTick(() => { callback(api.config.errors.connectionNotInRoom(connection, room)) }) }\n      }\n    }\n\n    api.chatRoom.generateMessagePayload = function (message) {\n      return {\n        message: message.message,\n        room: message.connection.room,\n        from: message.connection.id,\n        context: 'user',\n        sentAt: message.sentAt\n      }\n    }\n\n    api.chatRoom.incomingMessage = function (message) {\n      const messagePayload = api.chatRoom.generateMessagePayload(message)\n      for (let i in api.connections.connections) {\n        api.chatRoom.incomingMessagePerConnection(api.connections.connections[i], messagePayload)\n      }\n    }\n\n    api.chatRoom.incomingMessagePerConnection = function (connection, messagePayload) {\n      if (connection.canChat === true) {\n        if (connection.rooms.indexOf(messagePayload.room) > -1) {\n          api.chatRoom.handleCallbacks(connection, messagePayload.room, 'say', messagePayload, (error, newMessagePayload) => {\n            if (!error) { connection.sendMessage(newMessagePayload, 'say') }\n          })\n        }\n      }\n    }\n\n    api.chatRoom.list = function (callback) {\n      api.redis.clients.client.smembers(api.chatRoom.keys.rooms, (error, rooms) => {\n        if (typeof callback === 'function') { callback(error, rooms) }\n      })\n    }\n\n    api.chatRoom.add = function (room, callback) {\n      api.chatRoom.exists(room, function (error, found) {\n        if (error) { return callback(error) }\n        if (found === false) {\n          api.redis.clients.client.sadd(api.chatRoom.keys.rooms, room, (error, count) => {\n            if (typeof callback === 'function') { callback(error, count) }\n          })\n        } else {\n          if (typeof callback === 'function') { callback(api.config.errors.connectionRoomExists(room), null) }\n        }\n      })\n    }\n\n    api.chatRoom.destroy = function (room, callback) {\n      api.chatRoom.exists(room, (error, found) => {\n        if (error) { return callback(error) }\n        if (found === true) {\n          api.chatRoom.broadcast({}, room, api.config.errors.connectionRoomHasBeenDeleted(room), () => {\n            api.redis.clients.client.hgetall(api.chatRoom.keys.members + room, (error, membersHash) => {\n              if (error) { return callback(error) }\n\n              for (let id in membersHash) {\n                api.chatRoom.removeMember(id, room)\n              }\n\n              api.redis.clients.client.srem(api.chatRoom.keys.rooms, room, () => {\n                api.redis.clients.client.del(api.chatRoom.keys.members + room, () => {\n                  if (typeof callback === 'function') { callback() }\n                })\n              })\n            })\n          })\n        } else {\n          if (typeof callback === 'function') { callback(api.config.errors.connectionRoomNotExist(room), null) }\n        }\n      })\n    }\n\n    api.chatRoom.exists = function (room, callback) {\n      api.redis.clients.client.sismember(api.chatRoom.keys.rooms, room, (error, bool) => {\n        let found = false\n        if (bool === 1 || bool === true) {\n          found = true\n        }\n        if (typeof callback === 'function') { callback(error, found) }\n      })\n    }\n\n    api.chatRoom.sanitizeMemberDetails = function (memberData) {\n      return {\n        id: memberData.id,\n        joinedAt: memberData.joinedAt\n      }\n    }\n\n    api.chatRoom.roomStatus = function (room, callback) {\n      if (room) {\n        api.chatRoom.exists(room, (error, found) => {\n          if (error) { return callback(error) }\n          if (found === true) {\n            const key = api.chatRoom.keys.members + room\n            api.redis.clients.client.hgetall(key, (error, members) => {\n              if (error) { return callback(error) }\n\n              let cleanedMembers = {}\n              let count = 0\n              for (let id in members) {\n                const data = JSON.parse(members[id])\n                cleanedMembers[id] = api.chatRoom.sanitizeMemberDetails(data)\n                count++\n              }\n              callback(null, {\n                room: room,\n                members: cleanedMembers,\n                membersCount: count\n              })\n            })\n          } else {\n            if (typeof callback === 'function') { callback(api.config.errors.connectionRoomNotExist(room), null) }\n          }\n        })\n      } else {\n        if (typeof callback === 'function') { callback(api.config.errors.connectionRoomRequired(), null) }\n      }\n    }\n\n    api.chatRoom.generateMemberDetails = function (connection) {\n      return {\n        id: connection.id,\n        joinedAt: new Date().getTime(),\n        host: api.id\n      }\n    }\n\n    api.chatRoom.addMember = function (connectionId, room, callback) {\n      if (api.connections.connections[connectionId]) {\n        const connection = api.connections.connections[connectionId]\n        if (connection.rooms.indexOf(room) < 0) {\n          api.chatRoom.exists(room, (error, found) => {\n            if (error) { return callback(error) }\n\n            if (found === true) {\n              api.chatRoom.handleCallbacks(connection, room, 'join', null, (error) => {\n                if (error) {\n                  callback(error, false)\n                } else {\n                  const memberDetails = api.chatRoom.generateMemberDetails(connection)\n                  api.redis.clients.client.hset(api.chatRoom.keys.members + room, connection.id, JSON.stringify(memberDetails), () => {\n                    connection.rooms.push(room)\n                    if (typeof callback === 'function') { callback(null, true) }\n                  })\n                }\n              })\n            } else {\n              if (typeof callback === 'function') { callback(api.config.errors.connectionRoomNotExist(room), false) }\n            }\n          })\n        } else {\n          if (typeof callback === 'function') { callback(api.config.errors.connectionAlreadyInRoom(connection, room), false) }\n        }\n      } else {\n        api.redis.doCluster('api.chatRoom.addMember', [connectionId, room], connectionId, callback)\n      }\n    }\n\n    api.chatRoom.removeMember = function (connectionId, room, callback) {\n      if (api.connections.connections[connectionId]) {\n        const connection = api.connections.connections[connectionId]\n        if (connection.rooms.indexOf(room) > -1) {\n          api.chatRoom.exists(room, (error, found) => {\n            if (error) { return callback(error) }\n\n            if (found) {\n              api.chatRoom.handleCallbacks(connection, room, 'leave', null, (error) => {\n                if (error) {\n                  callback(error, false)\n                } else {\n                  api.redis.clients.client.hdel(api.chatRoom.keys.members + room, connection.id, () => {\n                    const index = connection.rooms.indexOf(room)\n                    if (index > -1) { connection.rooms.splice(index, 1) }\n                    if (typeof callback === 'function') { callback(null, true) }\n                  })\n                }\n              })\n            } else {\n              if (typeof callback === 'function') { callback(api.config.errors.connectionRoomNotExist(room), false) }\n            }\n          })\n        } else {\n          if (typeof callback === 'function') { callback(api.config.errors.connectionNotInRoom(connection, room), false) }\n        }\n      } else {\n        api.redis.doCluster('api.chatRoom.removeMember', [connectionId, room], connectionId, callback)\n      }\n    }\n\n    api.chatRoom.handleCallbacks = function (connection, room, direction, messagePayload, callback) {\n      let jobs = []\n      let newMessagePayload\n      if (messagePayload) { newMessagePayload = api.utils.objClone(messagePayload) }\n\n      api.chatRoom.globalMiddleware.forEach((name) => {\n        const m = api.chatRoom.middleware[name]\n        if (typeof m[direction] === 'function') {\n          jobs.push((done) => {\n            if (messagePayload) {\n              m[direction](connection, room, newMessagePayload, (error, data) => {\n                if (data) { newMessagePayload = data }\n                done(error, data)\n              })\n            } else {\n              m[direction](connection, room, done)\n            }\n          })\n        }\n      })\n\n      async.series(jobs, (error, data) => {\n        while (data.length > 0) {\n          const thisData = data.shift()\n          if (thisData) { newMessagePayload = thisData }\n        }\n        callback(error, newMessagePayload)\n      })\n    }\n\n    next()\n  },\n\n  start: function (api, next) {\n    api.redis.subscriptionHandlers.chat = (message) => {\n      if (api.chatRoom) {\n        api.chatRoom.incomingMessage(message)\n      }\n    }\n\n    if (api.config.general.startingChatRooms) {\n      for (let room in api.config.general.startingChatRooms) {\n        api.log(['ensuring the existence of the chatRoom: %s', room])\n        api.chatRoom.add(room)\n      }\n    }\n\n    next()\n  }\n\n}\n","/home/travis/build/npmtest/node-npmtest-actionhero/node_modules/actionhero/initializers/config.js":"'use strict'\n\nconst fs = require('fs')\nconst path = require('path')\nconst argv = require('optimist').argv\n\nmodule.exports = {\n  loadPriority: 0,\n  initialize: function (api, next) {\n    // api.env\n\n    if (api._startingParams && api._startingParams.api) {\n      api.utils.hashMerge(api, api._startingParams.api)\n    }\n\n    api.env = 'development'\n\n    if (argv.NODE_ENV) {\n      api.env = argv.NODE_ENV\n    } else if (process.env.NODE_ENV) {\n      api.env = process.env.NODE_ENV\n    }\n\n    // reloading in development mode\n\n    api.watchedFiles = []\n\n    api.watchFileAndAct = function (file, callback) {\n      file = path.normalize(file)\n\n      if (!fs.existsSync(file)) {\n        throw new Error(file + ' does not exist, and cannot be watched')\n      }\n\n      if (api.config.general.developmentMode === true && api.watchedFiles.indexOf(file) < 0) {\n        api.watchedFiles.push(file)\n        fs.watchFile(file, {interval: 1000}, (curr, prev) => {\n          if (\n            api.running === true &&\n            api.config.general.developmentMode === true &&\n            curr.mtime > prev.mtime\n          ) {\n            process.nextTick(() => {\n              let cleanPath = file\n              if (process.platform === 'win32') { cleanPath = file.replace(/\\//g, '\\\\') }\n              delete require.cache[require.resolve(cleanPath)]\n              callback(file)\n            })\n          }\n        })\n      }\n    }\n\n    api.unWatchAllFiles = function () {\n      for (let i in api.watchedFiles) {\n        fs.unwatchFile(api.watchedFiles[i])\n      }\n      api.watchedFiles = []\n    }\n\n    // We support multiple configuration paths as follows:\n    //\n    // 1. Use the project 'config' folder, if it exists.\n    // 2. \"actionhero --config=PATH1 --config=PATH2 --config=PATH3,PATH4\"\n    // 3. \"ACTIONHERO_CONFIG=PATH1,PATH2 npm start\"\n    //\n    // Note that if --config or ACTIONHERO_CONFIG are used, they _overwrite_ the use of the default \"config\" folder. If\n    // you wish to use both, you need to re-specify \"config\", e.g. \"--config=config,local-config\". Also, note that\n    // specifying multiple --config options on the command line does exactly the same thing as using one parameter with\n    // comma separators, however the environment variable method only supports the comma-delimited syntax.\n    let configPaths = []\n\n    function addConfigPath (pathToCheck, alreadySplit) {\n      if (typeof pathToCheck === 'string') {\n        if (!alreadySplit) {\n          addConfigPath(pathToCheck.split(','), true)\n        } else {\n          if (pathToCheck.charAt(0) !== '/') {\n            pathToCheck = path.resolve(api.projectRoot, pathToCheck)\n          }\n          if (fs.existsSync(pathToCheck)) {\n            configPaths.push(pathToCheck)\n          }\n        }\n      } else if (Array.isArray(pathToCheck)) {\n        pathToCheck.map((entry) => { addConfigPath(entry, alreadySplit) })\n      }\n    }\n\n    [argv.config, process.env.ACTIONHERO_CONFIG].map((entry) => { addConfigPath(entry, false) })\n\n    if (configPaths.length < 1) {\n      addConfigPath('config', false)\n    }\n\n    if (configPaths.length < 1) {\n      return next(new Error(configPaths + 'No config directory found in this project, specified with --config, or found in process.env.ACTIONHERO_CONFIG'))\n    }\n\n    const rebootCallback = (file) => {\n      api.log(['*** rebooting due to config change (%s) ***', file], 'info')\n      delete require.cache[require.resolve(file)]\n      api.commands.restart()\n    }\n\n    api.loadConfigDirectory = function (configPath, watch) {\n      const configFiles = api.utils.recursiveDirectoryGlob(configPath)\n\n      let loadRetries = 0\n      let loadErrors = {}\n      for (let i = 0, limit = configFiles.length; (i < limit); i++) {\n        const f = configFiles[i]\n        try {\n          // attempt configuration file load\n          let localConfig = require(f)\n          if (localConfig['default']) { api.config = api.utils.hashMerge(api.config, localConfig['default'], api) }\n          if (localConfig[api.env]) { api.config = api.utils.hashMerge(api.config, localConfig[api.env], api) }\n          // configuration file load success: clear retries and\n          // errors since progress has been made\n          loadRetries = 0\n          loadErrors = {}\n        } catch (error) {\n          // error loading configuration, abort if all remaining\n          // configuration files have been tried and failed\n          // indicating inability to progress\n          loadErrors[f] = {error: error, msg: error.toString()}\n          if (++loadRetries === limit - i) {\n            Object.keys(loadErrors).forEach((e) => {\n              console.log(loadErrors[e].error.stack)\n              console.log('')\n              delete loadErrors[e].error\n            })\n\n            return next(new Error('Unable to load configurations, errors: ' + JSON.stringify(loadErrors)))\n          }\n          // adjust configuration files list: remove and push\n          // failed configuration to the end of the list and\n          // continue with next file at same index\n          configFiles.push(configFiles.splice(i--, 1)[0])\n          continue\n        }\n\n        if (watch !== false) {\n          // configuration file loaded: set watch\n          api.watchFileAndAct(f, rebootCallback)\n        }\n      }\n\n      // We load the config twice. Utilize configuration files load order that succeeded on the first pass.\n      // This is to allow 'literal' values to be loaded whenever possible, and then for refrences to be resolved\n      configFiles.forEach((f) => {\n        const localConfig = require(f)\n        if (localConfig['default']) { api.config = api.utils.hashMerge(api.config, localConfig['default'], api) }\n        if (localConfig[api.env]) { api.config = api.utils.hashMerge(api.config, localConfig[api.env], api) }\n      })\n    }\n\n    api.config = {}\n\n    // load the default config of actionhero\n    api.loadConfigDirectory(path.join(__dirname, '/../config'), false)\n\n    // load the project specific config\n    configPaths.map(api.loadConfigDirectory)\n\n    // apply any configChanges\n    if (api._startingParams && api._startingParams.configChanges) {\n      api.config = api.utils.hashMerge(api.config, api._startingParams.configChanges)\n    }\n\n    process.nextTick(next)\n  },\n\n  start: function (api, callback) {\n    api.log(['environment: %s', api.env], 'notice')\n    callback()\n  }\n\n}\n","/home/travis/build/npmtest/node-npmtest-actionhero/node_modules/actionhero/initializers/connections.js":"'use strict'\n\nconst uuid = require('uuid')\n\nmodule.exports = {\n  loadPriority: 400,\n  initialize: function (api, next) {\n    api.connections = {\n\n      middleware: {},\n      globalMiddleware: [],\n\n      allowedVerbs: [\n        'quit',\n        'exit',\n        'documentation',\n        'paramAdd',\n        'paramDelete',\n        'paramView',\n        'paramsView',\n        'paramsDelete',\n        'roomAdd',\n        'roomLeave',\n        'roomView',\n        'detailsView',\n        'say'\n      ],\n\n      connections: {},\n\n      apply: function (connectionId, method, args, callback) {\n        if (args === undefined && callback === undefined && typeof method === 'function') {\n          callback = method; args = null; method = null\n        }\n        api.redis.doCluster('api.connections.applyCatch', [connectionId, method, args], connectionId, callback)\n      },\n\n      applyCatch: function (connectionId, method, args, callback) {\n        const connection = api.connections.connections[connectionId]\n        if (method && args) {\n          if (method === 'sendMessage' || method === 'sendFile') {\n            connection[method](args)\n          } else {\n            connection[method].apply(connection, args)\n          }\n        }\n        if (typeof callback === 'function') {\n          process.nextTick(() => {\n            callback(cleanConnection(connection))\n          })\n        }\n      },\n\n      addMiddleware: function (data) {\n        if (!data.name) { throw new Error('middleware.name is required') }\n        if (!data.priority) { data.priority = api.config.general.defaultMiddlewarePriority }\n        data.priority = Number(data.priority)\n        api.connections.middleware[data.name] = data\n\n        this.globalMiddleware.push(data.name)\n        this.globalMiddleware.sort((a, b) => {\n          if (api.connections.middleware[a].priority > api.connections.middleware[b].priority) {\n            return 1\n          } else {\n            return -1\n          }\n        })\n      }\n    }\n\n    const cleanConnection = function (connection) {\n      let clean = {}\n      for (let i in connection) {\n        if (i !== 'rawConnection') {\n          clean[i] = connection[i]\n        }\n      }\n      return clean\n    }\n\n    // {type: type, remotePort: remotePort, remoteIP: remoteIP, rawConnection: rawConnection}\n    // id is optional and will be generated if missing\n    api.Connection = function (data) {\n      this.setup(data)\n      api.connections.connections[this.id] = this\n\n      api.connections.globalMiddleware.forEach((middlewareName) => {\n        if (typeof api.connections.middleware[middlewareName].create === 'function') {\n          api.connections.middleware[middlewareName].create(this)\n        }\n      })\n    }\n\n    api.Connection.prototype.setup = function (data) {\n      if (data.id) {\n        this.id = data.id\n      } else {\n        this.id = this.generateID()\n      }\n      this.connectedAt = new Date().getTime();\n\n      ['type', 'rawConnection'].forEach((req) => {\n        if (data[req] === null || data[req] === undefined) { throw new Error(req + ' is required to create a new connection object') }\n        this[req] = data[req]\n      });\n\n      ['remotePort', 'remoteIP'].forEach((req) => {\n        if (data[req] === null || data[req] === undefined) {\n          if (api.config.general.enforceConnectionProperties === true) {\n            throw new Error(req + ' is required to create a new connection object')\n          } else {\n            data[req] = 0 // could be a random uuid as well?\n          }\n        }\n        this[req] = data[req]\n      })\n\n      const connectionDefaults = {\n        error: null,\n        fingerprint: this.id,\n        rooms: [],\n        params: {},\n        pendingActions: 0,\n        totalActions: 0,\n        messageCount: 0,\n        canChat: false\n      }\n\n      for (let i in connectionDefaults) {\n        if (this[i] === undefined && data[i] !== undefined) { this[i] = data[i] }\n        if (this[i] === undefined) { this[i] = connectionDefaults[i] }\n      }\n\n      api.i18n.invokeConnectionLocale(this)\n    }\n\n    api.Connection.prototype.localize = function (message) {\n      // this.locale will be sourced automatically\n      return api.i18n.localize(message, this)\n    }\n\n    api.Connection.prototype.generateID = function () {\n      return uuid.v4()\n    }\n\n    api.Connection.prototype.destroy = function (callback) {\n      this.destroyed = true\n\n      api.connections.globalMiddleware.forEach((middlewareName) => {\n        if (typeof api.connections.middleware[middlewareName].destroy === 'function') {\n          api.connections.middleware[middlewareName].destroy(this)\n        }\n      })\n\n      if (this.canChat === true) {\n        this.rooms.forEach((room) => {\n          api.chatRoom.removeMember(this.id, room)\n        })\n      }\n\n      const server = api.servers.servers[this.type]\n\n      if (server) {\n        if (server.attributes.logExits === true) {\n          server.log('connection closed', 'info', {to: this.remoteIP})\n        }\n        if (typeof server.goodbye === 'function') { server.goodbye(this) }\n      }\n\n      delete api.connections.connections[this.id]\n\n      if (typeof callback === 'function') { callback() }\n    }\n\n    api.Connection.prototype.set = function (key, value) {\n      this[key] = value\n    }\n\n    api.Connection.prototype.verbs = function (verb, words, callback) {\n      let key\n      let value\n      let room\n      const server = api.servers.servers[this.type]\n      const allowedVerbs = server.attributes.verbs\n      if (typeof words === 'function' && !callback) {\n        callback = words\n        words = []\n      }\n      if (!(words instanceof Array)) {\n        words = [words]\n      }\n      if (server && allowedVerbs.indexOf(verb) >= 0) {\n        server.log('verb', 'debug', {verb: verb, to: this.remoteIP, params: JSON.stringify(words)})\n        if (verb === 'quit' || verb === 'exit') {\n          server.goodbye(this)\n        } else if (verb === 'paramAdd') {\n          key = words[0]\n          value = words[1]\n          if ((words[0]) && (words[0].indexOf('=') >= 0)) {\n            let parts = words[0].split('=')\n            key = parts[0]\n            value = parts[1]\n          }\n          if (api.config.general.disableParamScrubbing || api.params.postVariables.indexOf(key) > 0) {\n            this.params[key] = value\n          }\n          if (typeof callback === 'function') { callback(null, null) }\n        } else if (verb === 'paramDelete') {\n          key = words[0]\n          delete this.params[key]\n          if (typeof callback === 'function') { callback(null, null) }\n        } else if (verb === 'paramView') {\n          key = words[0]\n          if (typeof callback === 'function') { callback(null, this.params[key]) }\n        } else if (verb === 'paramsView') {\n          if (typeof callback === 'function') { callback(null, this.params) }\n        } else if (verb === 'paramsDelete') {\n          for (let i in this.params) {\n            delete this.params[i]\n          }\n          if (typeof callback === 'function') { callback(null, null) }\n        } else if (verb === 'roomAdd') {\n          room = words[0]\n          api.chatRoom.addMember(this.id, room, (error, didHappen) => {\n            if (typeof callback === 'function') { callback(error, didHappen) }\n          })\n        } else if (verb === 'roomLeave') {\n          room = words[0]\n          api.chatRoom.removeMember(this.id, room, (error, didHappen) => {\n            if (typeof callback === 'function') { callback(error, didHappen) }\n          })\n        } else if (verb === 'roomView') {\n          room = words[0]\n          if (this.rooms.indexOf(room) > -1) {\n            api.chatRoom.roomStatus(room, (error, roomStatus) => {\n              if (typeof callback === 'function') { callback(error, roomStatus) }\n            })\n          } else {\n            if (typeof callback === 'function') { callback(new Error('not member of room ' + room)) }\n          }\n        } else if (verb === 'detailsView') {\n          let details = {}\n          details.id = this.id\n          details.fingerprint = this.fingerprint\n          details.remoteIP = this.remoteIP\n          details.remotePort = this.remotePort\n          details.params = this.params\n          details.connectedAt = this.connectedAt\n          details.rooms = this.rooms\n          details.totalActions = this.totalActions\n          details.pendingActions = this.pendingActions\n          if (typeof callback === 'function') { callback(null, details) }\n        } else if (verb === 'documentation') {\n          if (typeof callback === 'function') { callback(null, api.documentation.documentation) }\n        } else if (verb === 'say') {\n          room = words.shift()\n          api.chatRoom.broadcast(this, room, words.join(' '), (error) => {\n            if (typeof callback === 'function') { callback(error) }\n          })\n        } else {\n          if (typeof callback === 'function') { callback(new Error(api.config.errors.verbNotFound(this, verb)), null) }\n        }\n      } else {\n        if (typeof callback === 'function') { callback(new Error(api.config.errors.verbNotAllowed(this, verb)), null) }\n      }\n    }\n\n    next()\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-actionhero/node_modules/actionhero/initializers/documentation.js":"'use strict'\n\nmodule.exports = {\n  loadPriority: 999,\n  initialize: function (api, next) {\n    api.documentation = {\n      documentation: {},\n      build: () => {\n        let action\n        for (let i in api.actions.actions) {\n          for (let j in api.actions.actions[i]) {\n            action = api.actions.actions[i][j]\n            if (action.toDocument !== false) {\n              if (!api.documentation.documentation[action.name]) { api.documentation.documentation[action.name] = {} }\n              api.documentation.documentation[action.name][action.version] = {\n                name: action.name,\n                version: action.version,\n                description: action.description,\n                inputs: action.inputs,\n                outputExample: action.outputExample\n              }\n            }\n          }\n        }\n      }\n    }\n\n    api.documentation.build()\n    next()\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-actionhero/node_modules/actionhero/initializers/exceptions.js":"'use strict'\n\nconst os = require('os')\n\nmodule.exports = {\n  loadPriority: 130,\n  initialize: function (api, next) {\n    api.exceptionHandlers = {}\n    api.exceptionHandlers.reporters = []\n\n    const consoleReporter = function (error, type, name, objects, severity) {\n      let extraMessages = []\n\n      if (type === 'loader') {\n        extraMessages.push('! Failed to load ' + objects.fullFilePath)\n      } else if (type === 'action') {\n        extraMessages.push('! uncaught error from action: ' + name)\n        extraMessages.push('! connection details:')\n        const relevantDetails = ['action', 'remoteIP', 'type', 'params', 'room']\n        for (let i in relevantDetails) {\n          if (\n            objects.connection[relevantDetails[i]] !== null &&\n            objects.connection[relevantDetails[i]] !== undefined &&\n            typeof objects.connection[relevantDetails[i]] !== 'function'\n          ) {\n            extraMessages.push('!     ' + relevantDetails[i] + ': ' + JSON.stringify(objects.connection[relevantDetails[i]]))\n          }\n        }\n      } else if (type === 'task') {\n        extraMessages.push('! error from task: ' + name + ' on queue ' + objects.queue + ' (worker #' + objects.workerId + ')')\n        try {\n          extraMessages.push('!     arguments: ' + JSON.stringify(objects.task.args))\n        } catch (e) {}\n      } else {\n        extraMessages.push('! Error: ' + error.message)\n        extraMessages.push('!     Type: ' + type)\n        extraMessages.push('!     Name: ' + name)\n        extraMessages.push('!     Data: ' + JSON.stringify(objects))\n      }\n\n      for (let m in extraMessages) {\n        api.log(extraMessages[m], severity)\n      }\n      let lines\n      try {\n        lines = error.stack.split(os.EOL)\n      } catch (e) {\n        lines = new Error(error).stack.split(os.EOL)\n      }\n      for (let l in lines) {\n        let line = lines[l]\n        api.log('! ' + line, severity)\n      }\n      api.log('*', severity)\n    }\n\n    api.exceptionHandlers.reporters.push(consoleReporter)\n\n    api.exceptionHandlers.report = function (error, type, name, objects, severity) {\n      if (!severity) { severity = 'error' }\n      for (let i in api.exceptionHandlers.reporters) {\n        api.exceptionHandlers.reporters[i](error, type, name, objects, severity)\n      }\n    }\n\n    // /////////\n    // TYPES //\n    // /////////\n\n    api.exceptionHandlers.loader = function (fullFilePath, error) {\n      let name = 'loader:' + fullFilePath\n      api.exceptionHandlers.report(error, 'loader', name, {fullFilePath: fullFilePath}, 'alert')\n    }\n\n    api.exceptionHandlers.action = function (error, data, next) {\n      let simpleName\n      try {\n        simpleName = data.action\n      } catch (e) {\n        simpleName = error.message\n      }\n      let name = 'action:' + simpleName\n      api.exceptionHandlers.report(error, 'action', name, {connection: data.connection}, 'error')\n      data.connection.response = {} // no partial responses\n      if (typeof next === 'function') { next() }\n    }\n\n    api.exceptionHandlers.task = function (error, queue, task, workerId) {\n      let simpleName\n      try {\n        simpleName = task['class']\n      } catch (e) {\n        simpleName = error.message\n      }\n      let name = 'task:' + simpleName\n      api.exceptionHandlers.report(error, 'task', name, {task: task, queue: queue, workerId: workerId}, api.config.tasks.workerLogging.failure)\n    }\n\n    next()\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-actionhero/node_modules/actionhero/initializers/genericServer.js":"'use strict'\n\nconst EventEmitter = require('events').EventEmitter\nconst util = require('util')\n\nmodule.exports = {\n  loadPriority: 450,\n  initialize: function (api, next) {\n    // I am the prototypical generic server that all other types of servers inherit from.\n    // I shouldn't actually be used by a client\n    // Note the methods in this template server, as they are all required for 'real' servers\n\n    // //////////////////\n    // COMMON METHODS //\n    // //////////////////\n\n    // options are meant to be configurable in 'config.js'\n    // attributes are descriptions of the server:\n    /*\n\n      attributes = {\n        canChat: true,\n        logConnections: true,\n        logExits: true,\n        sendWelcomeMessage: true,\n        verbs: ['say', 'detailsView']\n      }\n\n    */\n\n    api.GenericServer = function (name, options, attributes) {\n      this.type = name\n      this.options = options\n      this.attributes = attributes\n\n      // you can overwrite attributes with options\n      // this could cause some problems, be careful\n      for (let key in this.options) {\n        if (this.attributes[key] !== null && this.attributes[key] !== undefined) {\n          this.attributes[key] = this.options[key]\n        }\n      }\n    }\n\n    util.inherits(api.GenericServer, EventEmitter)\n\n    api.GenericServer.prototype.buildConnection = function (data) {\n      const details = {\n        type: this.type,\n        id: data.id,\n        remotePort: data.remotePort,\n        remoteIP: data.remoteAddress,\n        rawConnection: data.rawConnection\n      }\n      if (this.attributes.canChat === true) { details.canChat = true }\n      if (data.fingerprint) { details.fingerprint = data.fingerprint }\n      let connection = new api.Connection(details)\n\n      connection.sendMessage = (message) => {\n        this.sendMessage(connection, message)\n      }\n\n      connection.sendFile = (path) => {\n        connection.params.file = path\n        this.processFile(connection)\n      }\n\n      this.emit('connection', connection)\n\n      if (this.attributes.logConnections === true) {\n        this.log('new connection', 'info', {to: connection.remoteIP})\n      }\n\n      if (this.attributes.sendWelcomeMessage === true) {\n        connection.sendMessage({welcome: api.config.general.welcomeMessage, context: 'api'})\n      }\n\n      if (typeof this.attributes.sendWelcomeMessage === 'number') {\n        setTimeout(() => {\n          try {\n            connection.sendMessage({welcome: api.config.general.welcomeMessage, context: 'api'})\n          } catch (e) {\n            api.log(e, 'error')\n          }\n        }, this.attributes.sendWelcomeMessage)\n      }\n    }\n\n    api.GenericServer.prototype.processAction = function (connection) {\n      const ActionProcessor = new api.ActionProcessor(connection, (data) => {\n        this.emit('actionComplete', data)\n      })\n\n      ActionProcessor.processAction()\n    }\n\n    api.GenericServer.prototype.processFile = function (connection) {\n      api.staticFile.get(connection, (connection, error, fileStream, mime, length, lastModified) => {\n        this.sendFile(connection, error, fileStream, mime, length, lastModified)\n      })\n    }\n\n    api.GenericServer.prototype.connections = function () {\n      let connections = []\n\n      for (let i in api.connections.connections) {\n        let connection = api.connections.connections[i]\n        if (connection.type === this.type) { connections.push(connection) }\n      }\n\n      return connections\n    }\n\n    api.GenericServer.prototype.log = function (message, severity, data) {\n      api.log(['[server: %s] %s', this.type, message], severity, data)\n    }\n\n    const methodNotDefined = function () {\n      throw new Error('The containing method should be defined for this server type')\n    }\n\n    // /////////////////////////////////////\n    // METHODS WHICH MUST BE OVERWRITTEN //\n    // /////////////////////////////////////\n\n    // I am invoked as part of boot\n    api.GenericServer.prototype.start = function (next) { methodNotDefined() }\n\n    // I am invoked as part of shutdown\n    api.GenericServer.prototype.stop = function (next) { methodNotDefined() }\n\n    // This method will be appended to the connection as 'connection.sendMessage'\n    api.GenericServer.prototype.sendMessage = function (connection, message) { methodNotDefined() }\n\n    // This method will be used to gracefully disconnect the client\n    api.GenericServer.prototype.goodbye = function (connection, reason) { methodNotDefined() }\n\n    next()\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-actionhero/node_modules/actionhero/initializers/id.js":"'use strict'\n\nconst cluster = require('cluster')\nconst path = require('path')\nconst argv = require('optimist').argv\n\nmodule.exports = {\n  loadPriority: 10,\n  startPriority: 2,\n  initialize: function (api, next) {\n    if (argv.title) {\n      api.id = argv.title\n    } else if (process.env.ACTIONHERO_TITLE) {\n      api.id = process.env.ACTIONHERO_TITLE\n    } else if (!api.config.general.id) {\n      let externalIP = api.utils.getExternalIPAddress()\n      if (externalIP === false) {\n        let message = ' * Error fetching this hosts external IP address; setting id base to \\'actionhero\\''\n        try {\n          api.log(message, 'crit')\n        } catch (e) {\n          console.log(message)\n        }\n        externalIP = 'actionhero'\n      }\n\n      api.id = externalIP\n      if (cluster.isWorker) { api.id += ':' + process.pid }\n    } else {\n      api.id = api.config.general.id\n    }\n\n    api.actionheroVersion = require('..' + path.sep + 'package.json').version\n\n    next()\n  },\n\n  start: function (api, next) {\n    api.log(['server ID: %s', api.id], 'notice')\n    next()\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-actionhero/node_modules/actionhero/initializers/params.js":"'use strict'\n\nmodule.exports = {\n  loadPriority: 420,\n  initialize: function (api, next) {\n    api.params = {}\n\n    // special params we will always accept\n    api.params.globalSafeParams = [\n      'file',\n      'apiVersion',\n      'callback',\n      'action'\n    ]\n\n    api.params.buildPostVariables = function () {\n      let postVariables = []\n      let i\n      let j\n\n      api.params.globalSafeParams.forEach(function (p) {\n        postVariables.push(p)\n      })\n\n      for (i in api.actions.actions) {\n        for (j in api.actions.actions[i]) {\n          let action = api.actions.actions[i][j]\n          for (let key in action.inputs) {\n            postVariables.push(key)\n          }\n        }\n      }\n\n      api.params.postVariables = api.utils.arrayUniqueify(postVariables)\n      return api.params.postVariables\n    }\n\n    api.params.buildPostVariables()\n    next()\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-actionhero/node_modules/actionhero/initializers/pids.js":"'use strict'\n\nconst fs = require('fs')\nconst cluster = require('cluster')\n\nmodule.exports = {\n  startPriority: 1,\n  loadPriority: 50,\n  initialize: function (api, next) {\n    api.pids = {}\n    api.pids.pid = process.pid\n    api.pids.path = api.config.general.paths.pid[0] // it would be silly to have more than one pid\n\n    api.pids.sanitizeId = function () {\n      let pidfile = api.id\n      pidfile = pidfile.replace(new RegExp(':', 'g'), '-')\n      pidfile = pidfile.replace(new RegExp(' ', 'g'), '_')\n      pidfile = pidfile.replace(new RegExp('\\r', 'g'), '') // eslint-disable-line\n      pidfile = pidfile.replace(new RegExp('\\n', 'g'), '') // eslint-disable-line \n\n      return pidfile\n    }\n\n    if (cluster.isMaster) {\n      api.pids.title = 'actionhero-' + api.pids.sanitizeId()\n    } else {\n      api.pids.title = api.pids.sanitizeId()\n    }\n\n    try { fs.mkdirSync(api.pids.path) } catch (e) {};\n\n    api.pids.writePidFile = function () {\n      fs.writeFileSync(api.pids.path + '/' + api.pids.title, api.pids.pid.toString(), 'ascii')\n    }\n\n    api.pids.clearPidFile = function () {\n      try {\n        fs.unlinkSync(api.pids.path + '/' + api.pids.title)\n      } catch (e) {\n        api.log('Unable to remove pidfile', 'error', e)\n      }\n    }\n\n    next()\n  },\n\n  start: function (api, next) {\n    api.pids.writePidFile()\n    api.log(['pid: %s', process.pid], 'notice')\n    next()\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-actionhero/node_modules/actionhero/initializers/resque.js":"'use strict'\n\nconst NR = require('node-resque')\n\nmodule.exports = {\n  startPriority: 200,\n  stopPriority: 100,\n  loadPriority: 600,\n  initialize: function (api, next) {\n    const resqueOverrides = api.config.tasks.resque_overrides\n\n    api.resque = {\n      verbose: false,\n      queue: null,\n      multiWorker: null,\n      scheduler: null,\n      connectionDetails: {redis: api.redis.clients.tasks},\n\n      startQueue: function (callback) {\n        let Queue = NR.queue\n        if (resqueOverrides && resqueOverrides.queue) { Queue = resqueOverrides.queue }\n        this.queue = new Queue({connection: this.connectionDetails}, api.tasks.jobs)\n\n        this.queue.on('error', (error) => {\n          api.log(error, 'error', '[api.resque.queue]')\n        })\n\n        this.queue.connect(callback)\n      },\n\n      stopQueue: function (callback) {\n        if (api.resque.queue) { api.resque.queue.end(callback) } else { callback() }\n      },\n\n      startScheduler: function (callback) {\n        let Scheduler = NR.scheduler\n        if (resqueOverrides && resqueOverrides.scheduler) { Scheduler = resqueOverrides.scheduler }\n        if (api.config.tasks.scheduler === true) {\n          this.schedulerLogging = api.config.tasks.schedulerLogging\n          this.scheduler = new Scheduler({connection: this.connectionDetails, timeout: api.config.tasks.timeout})\n\n          this.scheduler.on('error', (error) => {\n            api.log(error, 'error', '[api.resque.scheduler]')\n          })\n\n          this.scheduler.connect(() => {\n            this.scheduler.on('start', () => { api.log('resque scheduler started', this.schedulerLogging.start) })\n            this.scheduler.on('end', () => { api.log('resque scheduler ended', this.schedulerLogging.end) })\n            this.scheduler.on('poll', () => { api.log('resque scheduler polling', this.schedulerLogging.poll) })\n            this.scheduler.on('working_timestamp', (timestamp) => { api.log(['resque scheduler working timestamp %s', timestamp], this.schedulerLogging.working_timestamp) })\n            this.scheduler.on('transferred_job', (timestamp, job) => { api.log(['resque scheduler enqueuing job %s', timestamp], this.schedulerLogging.transferred_job, job) })\n            this.scheduler.on('master', (state) => { api.log(['This node is now the Resque scheduler master']) })\n\n            this.scheduler.start()\n            callback()\n          })\n        } else {\n          callback()\n        }\n      },\n\n      stopScheduler: function (callback) {\n        if (!this.scheduler) {\n          callback()\n        } else {\n          this.scheduler.end(() => {\n            delete this.scheduler\n            callback()\n          })\n        }\n      },\n\n      startMultiWorker: function (callback) {\n        let MultiWorker = NR.multiWorker\n        if (resqueOverrides && resqueOverrides.multiWorker) { MultiWorker = resqueOverrides.multiWorker }\n        this.workerLogging = api.config.tasks.workerLogging\n        this.schedulerLogging = api.config.tasks.schedulerLogging\n\n        this.multiWorker = new MultiWorker({\n          connection: api.resque.connectionDetails,\n          queues: api.config.tasks.queues,\n          timeout: api.config.tasks.timeout,\n          checkTimeout: api.config.tasks.checkTimeout,\n          minTaskProcessors: api.config.tasks.minTaskProcessors,\n          maxTaskProcessors: api.config.tasks.maxTaskProcessors,\n          maxEventLoopDelay: api.config.tasks.maxEventLoopDelay,\n          toDisconnectProcessors: api.config.tasks.toDisconnectProcessors\n        }, api.tasks.jobs)\n\n        // normal worker emitters\n        this.multiWorker.on('start', (workerId) => { api.log('worker: started', this.workerLogging.start, {workerId: workerId}) })\n        this.multiWorker.on('end', (workerId) => { api.log('worker: ended', this.workerLogging.end, {workerId: workerId}) })\n        this.multiWorker.on('cleaning_worker', (workerId, worker, pid) => { api.log(['worker: cleaning old worker %s, (%s)', worker, pid], this.workerLogging.cleaning_worker) })\n        this.multiWorker.on('poll', (workerId, queue) => { api.log(['worker: polling %s', queue], this.workerLogging.poll, {workerId: workerId}) })\n        this.multiWorker.on('job', (workerId, queue, job) => { api.log(['worker: working job %s', queue], this.workerLogging.job, {workerId: workerId, job: {class: job['class'], queue: job.queue}}) })\n        this.multiWorker.on('reEnqueue', (workerId, queue, job, plugin) => { api.log('worker: reEnqueue job', this.workerLogging.reEnqueue, {workerId: workerId, plugin: plugin, job: {class: job['class'], queue: job.queue}}) })\n        this.multiWorker.on('success', (workerId, queue, job, result) => { api.log(['worker: job success %s', queue], this.workerLogging.success, {workerId: workerId, job: {class: job['class'], queue: job.queue}, result: result}) })\n        this.multiWorker.on('pause', (workerId) => { api.log('worker: paused', this.workerLogging.pause, {workerId: workerId}) })\n\n        this.multiWorker.on('failure', (workerId, queue, job, failure) => { api.exceptionHandlers.task(failure, queue, job, workerId) })\n        this.multiWorker.on('error', (workerId, queue, job, error) => { api.exceptionHandlers.task(error, queue, job, workerId) })\n\n        // multiWorker emitters\n        this.multiWorker.on('internalError', (error) => { api.log(error, this.workerLogging.internalError) })\n        this.multiWorker.on('multiWorkerAction', (verb, delay) => { api.log(['*** checked for worker status: %s (event loop delay: %sms)', verb, delay], this.workerLogging.multiWorkerAction) })\n\n        if (api.config.tasks.minTaskProcessors > 0) {\n          this.multiWorker.start(() => {\n            if (typeof callback === 'function') { callback() }\n          })\n        } else {\n          if (typeof callback === 'function') { callback() }\n        }\n      },\n\n      stopMultiWorker: function (callback) {\n        if (this.multiWorker && api.config.tasks.minTaskProcessors > 0) {\n          this.multiWorker.stop(() => {\n            api.log('task workers stopped')\n            callback()\n          })\n        } else {\n          callback()\n        }\n      }\n    }\n\n    next()\n  },\n\n  start: function (api, next) {\n    if (api.config.tasks.minTaskProcessors === 0 && api.config.tasks.maxTaskProcessors > 0) {\n      api.config.tasks.minTaskProcessors = 1\n    }\n\n    api.resque.startQueue(function () {\n      api.resque.startScheduler(function () {\n        api.resque.startMultiWorker(function () {\n          next()\n        })\n      })\n    })\n  },\n\n  stop: function (api, next) {\n    api.resque.stopScheduler(function () {\n      api.resque.stopMultiWorker(function () {\n        api.resque.stopQueue(function () {\n          next()\n        })\n      })\n    })\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-actionhero/node_modules/actionhero/initializers/servers.js":"'use strict'\n\nconst path = require('path')\nconst async = require('async')\n\nmodule.exports = {\n  startPriority: 900,\n  stopPriority: 100,\n  loadPriority: 599,\n  initialize: function (api, next) {\n    api.servers = {}\n    api.servers.servers = {}\n\n    // Load the servers\n\n    let serverFolders = [\n      path.resolve(path.join(__dirname, '/../servers'))\n    ]\n\n    api.config.general.paths.server.forEach((p) => {\n      p = path.resolve(p)\n      if (serverFolders.indexOf(p) < 0) {\n        serverFolders.push(p)\n      }\n    })\n\n    let jobs = []\n\n    serverFolders.forEach((p) => {\n      api.utils.recursiveDirectoryGlob(p).forEach((f) => {\n        let parts = f.split(/[/\\\\]+/)\n        let serverName = parts[(parts.length - 1)].split('.')[0]\n        if (api.config.servers[serverName] && api.config.servers[serverName].enabled === true) {\n          let init = require(f).initialize\n          let options = api.config.servers[serverName]\n          jobs.push((done) => {\n            init(api, options, (serverObject) => {\n              api.servers.servers[serverName] = serverObject\n              api.log(['Initialized server: %s', serverName], 'debug')\n              return done()\n            })\n          })\n        }\n        api.watchFileAndAct(f, () => {\n          api.log(['*** Rebooting due to server (%s) change ***', serverName], 'info')\n          api.commands.restart()\n        })\n      })\n    })\n\n    async.series(jobs, next)\n  },\n\n  start: function (api, next) {\n    let jobs = []\n    Object.keys(api.servers.servers).forEach((serverName) => {\n      let server = api.servers.servers[serverName]\n      if (server && server.options.enabled === true) {\n        let message = ''\n        let messageArgs = []\n        message += 'Starting server: `%s`'\n        messageArgs.push(serverName)\n        if (api.config.servers[serverName].bindIP) {\n          message += ' @ %s'\n          messageArgs.push(api.config.servers[serverName].bindIP)\n        }\n        if (api.config.servers[serverName].port) {\n          message += ':%s'\n          messageArgs.push(api.config.servers[serverName].port)\n        }\n\n        jobs.push((done) => {\n          api.log([message].concat(messageArgs), 'notice')\n          server.start((error) => {\n            if (error) { return done(error) }\n            api.log(['Server started: %s', serverName], 'debug')\n            return done()\n          })\n        })\n      }\n    })\n\n    async.series(jobs, next)\n  },\n\n  stop: function (api, next) {\n    let jobs = []\n    Object.keys(api.servers.servers).forEach((serverName) => {\n      let server = api.servers.servers[serverName]\n      if ((server && server.options.enabled === true) || !server) {\n        jobs.push((done) => {\n          api.log(['Stopping server: %s', serverName], 'notice')\n          server.stop((error) => {\n            if (error) { return done(error) }\n            api.log(['Server stopped: %s', serverName], 'debug')\n            return done()\n          })\n        })\n      }\n    })\n\n    async.series(jobs, next)\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-actionhero/node_modules/actionhero/initializers/specHelper.js":"'use strict'\n\nconst uuid = require('uuid')\nconst NR = require('node-resque')\n\nmodule.exports = {\n  startPriority: 901,\n  loadPriority: 900,\n  initialize: function (api, next) {\n    if (api.env === 'test' || process.env.SPECHELPER === 'true' || process.env.SPECHELPER === true) {\n      api.specHelper = {\n        returnMetadata: true\n      }\n\n      // create a test 'server' to run actions\n      api.specHelper.initialize = function (api, options, next) {\n        const type = 'testServer'\n        const attributes = {\n          canChat: true,\n          logConnections: false,\n          logExits: false,\n          sendWelcomeMessage: true,\n          verbs: api.connections.allowedVerbs\n        }\n\n        const server = new api.GenericServer(type, options, attributes)\n\n        server.start = function (next) {\n          api.log('loading the testServer', 'warning')\n          next()\n        }\n\n        server.stop = function (next) {\n          next()\n        }\n\n        server.sendMessage = function (connection, message, messageCount) {\n          process.nextTick(() => {\n            connection.messages.push(message)\n            if (typeof connection.actionCallbacks[messageCount] === 'function') {\n              connection.actionCallbacks[messageCount](message, connection)\n              delete connection.actionCallbacks[messageCount]\n            }\n          })\n        }\n\n        server.sendFile = function (connection, error, fileStream, mime, length) {\n          let content = ''\n          let response = {\n            error: error,\n            content: null,\n            mime: mime,\n            length: length\n          }\n\n          try {\n            if (!error) {\n              fileStream.on('data', (d) => { content += d })\n              fileStream.on('end', () => {\n                response.content = content\n                server.sendMessage(connection, response, connection.messageCount)\n              })\n            } else {\n              server.sendMessage(connection, response, connection.messageCount)\n            }\n          } catch (e) {\n            api.log(e, 'warning')\n            server.sendMessage(connection, response, connection.messageCount)\n          }\n        }\n\n        server.goodbye = function () {\n          //\n        }\n\n        server.on('connection', function (connection) {\n          connection.messages = []\n          connection.actionCallbacks = {}\n        })\n\n        server.on('actionComplete', function (data) {\n          if (typeof data.response === 'string' || Array.isArray(data.response)) {\n            if (data.response.error) {\n              data.response = api.config.errors.serializers.servers.specHelper(data.response.error)\n            }\n          } else {\n            if (data.response.error) {\n              data.response.error = api.config.errors.serializers.servers.specHelper(data.response.error)\n            }\n\n            if (api.specHelper.returnMetadata) {\n              data.response.messageCount = data.messageCount\n\n              data.response.serverInformation = {\n                serverName: api.config.general.serverName,\n                apiVersion: api.config.general.apiVersion\n              }\n\n              data.response.requesterInformation = {\n                id: data.connection.id,\n                remoteIP: data.connection.remoteIP,\n                receivedParams: {}\n              }\n\n              for (let k in data.params) {\n                data.response.requesterInformation.receivedParams[k] = data.params[k]\n              }\n            }\n          }\n\n          if (data.toRender === true) {\n            server.sendMessage(data.connection, data.response, data.messageCount)\n          }\n        })\n\n        next(server)\n      }\n\n      api.specHelper.connection = function () {\n        let id = uuid.v4()\n        api.servers.servers.testServer.buildConnection({\n          id: id,\n          rawConnection: {},\n          remoteAddress: 'testServer',\n          remotePort: 0\n        })\n\n        return api.connections.connections[id]\n      }\n\n      api.specHelper.Connection = api.specHelper.connection\n\n      // create helpers to run an action\n      // data can be a params hash or a connection\n      api.specHelper.runAction = function (actionName, input, next) {\n        let connection\n        if (typeof input === 'function' && !next) {\n          next = input\n          input = {}\n        }\n        if (input.id && input.type === 'testServer') {\n          connection = input\n        } else {\n          connection = new api.specHelper.Connection()\n          connection.params = input\n        }\n        connection.params.action = actionName\n\n        connection.messageCount++\n        if (typeof next === 'function') {\n          connection.actionCallbacks[(connection.messageCount)] = next\n        }\n\n        process.nextTick(() => {\n          api.servers.servers.testServer.processAction(connection)\n        })\n      }\n\n      // helpers to get files\n      api.specHelper.getStaticFile = function (file, next) {\n        let connection = new api.specHelper.Connection()\n        connection.params.file = file\n\n        connection.messageCount++\n        if (typeof next === 'function') {\n          connection.actionCallbacks[(connection.messageCount)] = next\n        }\n\n        api.servers.servers.testServer.processFile(connection)\n      }\n\n      // create helpers to run a task\n      api.specHelper.runTask = function (taskName, params, next) {\n        api.tasks.tasks[taskName].run(api, params, next)\n      }\n\n      api.specHelper.runFullTask = function (taskName, params, next) {\n        let options = {\n          connection: api.redis.clients.tasks,\n          queues: api.config.tasks.queues || ['default']\n        }\n\n        let worker = new NR.worker(options, api.tasks.jobs) // eslint-disable-line\n        worker.connect((error) => {\n          if (error) {\n            return next(error)\n          }\n\n          worker.performInline(taskName, params, (error, result) => {\n            worker.end()\n            next(error, result)\n          })\n        })\n      }\n\n      next()\n    } else {\n      next()\n    }\n  },\n\n  start: function (api, next) {\n    if (api.env === 'test' || process.env.SPECHELPER === 'true' || process.env.SPECHELPER === true) {\n      api.specHelper.initialize(api, {}, (serverObject) => {\n        api.servers.servers.testServer = serverObject\n        api.servers.servers.testServer.start(() => {\n          next()\n        })\n      })\n    } else {\n      next()\n    }\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-actionhero/node_modules/actionhero/initializers/staticFile.js":"'use strict'\n\nconst fs = require('fs')\nconst path = require('path')\nconst Mime = require('mime')\n\nmodule.exports = {\n  loadPriority: 510,\n  initialize: function (api, next) {\n    api.staticFile = {\n\n      searchLoactions: [],\n\n      searchPath: function (connection, counter) {\n        if (!counter) { counter = 0 }\n        if (api.staticFile.searchLoactions.length === 0 || counter >= api.staticFile.searchLoactions.length) {\n          return null\n        } else {\n          return api.staticFile.searchLoactions[counter]\n        }\n      },\n\n      // connection.params.file should be set\n      // callback is of the form: callback(connection, error, fileStream, mime, length)\n      get: function (connection, callback, counter) {\n        if (!counter) { counter = 0 }\n        if (!connection.params.file || !api.staticFile.searchPath(connection, counter)) {\n          this.sendFileNotFound(connection, api.config.errors.fileNotProvided(connection), callback)\n        } else {\n          let file\n          if (!path.isAbsolute(connection.params.file)) {\n            file = path.normalize(api.staticFile.searchPath(connection, counter) + '/' + connection.params.file)\n          } else {\n            file = connection.params.file\n          }\n\n          if (file.indexOf(path.normalize(api.staticFile.searchPath(connection, counter))) !== 0) {\n            api.staticFile.get(connection, callback, counter + 1)\n          } else {\n            this.checkExistence(file, (error, exists, truePath) => {\n              if (error) { throw error }\n              if (exists) {\n                this.sendFile(truePath, connection, callback)\n              } else {\n                api.staticFile.get(connection, callback, counter + 1)\n              }\n            })\n          }\n        }\n      },\n\n      sendFile: function (file, connection, callback) {\n        let lastModified\n        fs.stat(file, (error, stats) => {\n          if (error) {\n            this.sendFileNotFound(connection, api.config.errors.fileReadError(connection, String(error)), callback)\n          } else {\n            let mime = Mime.lookup(file)\n            let length = stats.size\n            let fileStream = fs.createReadStream(file)\n            let start = new Date().getTime()\n            lastModified = stats.mtime\n            fileStream.on('end', () => {\n              let duration = new Date().getTime() - start\n              this.logRequest(file, connection, length, duration, true)\n            })\n            fileStream.on('error', (error) => {\n              api.log(error)\n            })\n            fileStream.on('open', () => {\n              callback(connection, null, fileStream, mime, length, lastModified)\n            })\n          }\n        })\n      },\n\n      sendFileNotFound: function (connection, errorMessage, callback) {\n        connection.error = new Error(errorMessage)\n        this.logRequest('{not found}', connection, null, null, false)\n        callback(connection, api.config.errors.fileNotFound(connection), null, 'text/html', api.config.errors.fileNotFound(connection).length)\n      },\n\n      checkExistence: function (file, callback) {\n        fs.stat(file, (error, stats) => {\n          if (error) {\n            callback(null, false, file)\n          } else {\n            if (stats.isDirectory()) {\n              let indexPath = file + '/' + api.config.general.directoryFileType\n              api.staticFile.checkExistence(indexPath, callback)\n            } else if (stats.isSymbolicLink()) {\n              fs.readLink(file, function (error, truePath) {\n                if (error) {\n                  callback(null, false, file)\n                } else {\n                  truePath = path.normalize(truePath)\n                  api.staticFile.checkExistence(truePath, callback)\n                }\n              })\n            } else if (stats.isFile()) {\n              callback(null, true, file)\n            } else {\n              callback(null, false, file)\n            }\n          }\n        })\n      },\n\n      logRequest: function (file, connection, length, duration, success) {\n        api.log(['[ file @ %s ]', connection.type], api.config.general.fileRequestLogLevel, {\n          to: connection.remoteIP,\n          file: file,\n          requestedFile: connection.params.file,\n          size: length,\n          duration: duration,\n          success: success\n        })\n      }\n\n    }\n\n    // load in the explicit public paths first\n    if (api.config.general.paths !== undefined) {\n      api.config.general.paths['public'].forEach(function (p) {\n        api.staticFile.searchLoactions.push(path.normalize(p))\n      })\n    }\n\n    // source the .linked paths from plugins\n    if (api.config.general.paths !== undefined) {\n      api.config.general.paths['public'].forEach((p) => {\n        let pluginPath = p + path.sep + 'plugins'\n        if (fs.existsSync(pluginPath)) {\n          fs.readdirSync(pluginPath).forEach(function (file) {\n            let parts = file.split('.')\n            let name = parts[0]\n            if (parts[(parts.length - 1)] === 'link' && fs.readFileSync(pluginPath + path.sep + file).toString() === 'public') {\n              api.config.general.paths.plugin.forEach(function (potentialPluginPath) {\n                potentialPluginPath = path.normalize(potentialPluginPath + path.sep + name + path.sep + 'public')\n                if (fs.existsSync(potentialPluginPath) && api.staticFile.searchLoactions.indexOf(potentialPluginPath) < 0) {\n                  api.staticFile.searchLoactions.push(potentialPluginPath)\n                }\n              })\n            }\n          })\n        }\n      })\n    }\n\n    api.log('Static files will be served from these directories', 'debug', api.staticFile.searchLoactions)\n    next()\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-actionhero/node_modules/actionhero/initializers/utils.js":"'use strict'\n\nconst fs = require('fs')\nconst path = require('path')\nconst async = require('async')\n\nmodule.exports = {\n  loadPriority: 0,\n  initialize: function (api, next) {\n    if (!api.utils) { api.utils = {} }\n\n    // //////////////////////////////////////////////////////////////////////////\n    // merge two hashes recursively\n    api.utils.hashMerge = function (a, b, arg) {\n      let c = {}\n      let i\n      let response\n\n      for (i in a) {\n        if (api.utils.isPlainObject(a[i]) && Object.keys(a[i]).length > 0) {\n          c[i] = api.utils.hashMerge(c[i], a[i], arg)\n        } else {\n          if (typeof a[i] === 'function') {\n            response = a[i](arg)\n            if (api.utils.isPlainObject(response)) {\n              c[i] = api.utils.hashMerge(c[i], response, arg)\n            } else {\n              c[i] = response\n            }\n          } else {\n            c[i] = a[i]\n          }\n        }\n      }\n      for (i in b) {\n        if (api.utils.isPlainObject(b[i]) && Object.keys(b[i]).length > 0) {\n          c[i] = api.utils.hashMerge(c[i], b[i], arg)\n        } else {\n          if (typeof b[i] === 'function') {\n            response = b[i](arg)\n            if (api.utils.isPlainObject(response)) {\n              c[i] = api.utils.hashMerge(c[i], response, arg)\n            } else {\n              c[i] = response\n            }\n          } else {\n            c[i] = b[i]\n          }\n        }\n      }\n      return c\n    }\n\n    api.utils.isPlainObject = function (o) {\n      const safeTypes = [Boolean, Number, String, Function, Array, Date, RegExp, Buffer]\n      const safeInstances = ['boolean', 'number', 'string', 'function']\n      const expandPreventMatchKey = '_toExpand' // set `_toExpand = false` within an object if you don't want to expand it\n      let i\n\n      if (!o) { return false }\n      if ((o instanceof Object) === false) { return false }\n      for (i in safeTypes) {\n        if (o instanceof safeTypes[i]) { return false }\n      }\n      for (i in safeInstances) {\n        if (typeof o === safeInstances[i]) { return false } //eslint-disable-line\n      }\n      if (o[expandPreventMatchKey] === false) { return false }\n      return (o.toString() === '[object Object]')\n    }\n\n    // //////////////////////////////////////////////////////////////////////////\n    // string to hash\n    // http://stackoverflow.com/questions/6393943/convert-javascript-string-in-dot-notation-into-an-object-reference\n    api.utils.stringToHash = function (path, object) {\n      if (!object) { object = api }\n      function _index (obj, i) { return obj[i] }\n      return path.split('.').reduce(_index, object)\n    }\n\n    // //////////////////////////////////////////////////////////////////////////\n    // unique-ify an array\n    api.utils.arrayUniqueify = function (arr) {\n      let a = []\n      for (let i = 0; i < arr.length; i++) {\n        for (let j = i + 1; j < arr.length; j++) {\n          if (arr[i] === arr[j]) { j = ++i }\n        }\n        a.push(arr[i])\n      }\n      return a\n    }\n\n    // //////////////////////////////////////////////////////////////////////////\n    // get all .js files in a directory\n    api.utils.recursiveDirectoryGlob = function (dir, extension, followLinkFiles) {\n      let results = []\n\n      if (!extension) { extension = '.js' }\n      if (!followLinkFiles) { followLinkFiles = true }\n\n      extension = extension.replace('.', '')\n\n      if (fs.existsSync(dir)) {\n        fs.readdirSync(dir).forEach((file) => {\n          let fullFilePath = path.join(dir, file)\n          if (file[0] !== '.') { // ignore 'system' files\n            let stats = fs.statSync(fullFilePath)\n            let child\n            if (stats.isDirectory()) {\n              child = api.utils.recursiveDirectoryGlob(fullFilePath, extension, followLinkFiles)\n              child.forEach((c) => { results.push(c) })\n            } else if (stats.isSymbolicLink()) {\n              let realPath = fs.readlinkSync(fullFilePath)\n              child = api.utils.recursiveDirectoryGlob(realPath, extension, followLinkFiles)\n              child.forEach((c) => { results.push(c) })\n            } else if (stats.isFile()) {\n              let fileParts = file.split('.')\n              let ext = fileParts[(fileParts.length - 1)]\n              // real file match\n              if (ext === extension) { results.push(fullFilePath) }\n              // linkfile traversal\n              if (ext === 'link' && followLinkFiles === true) {\n                let linkedPath = api.utils.sourceRelativeLinkPath(fullFilePath, api.config.general.paths.plugin)\n                if (linkedPath) {\n                  child = api.utils.recursiveDirectoryGlob(linkedPath, extension, followLinkFiles)\n                  child.forEach((c) => { results.push(c) })\n                } else {\n                  try {\n                    api.log(['cannot find linked refrence to `%s`', file], 'warning')\n                  } catch (e) {\n                    throw new Error('cannot find linked refrence to ' + file)\n                  }\n                }\n              }\n            }\n          }\n        })\n      }\n\n      return results.sort()\n    }\n\n    api.utils.sourceRelativeLinkPath = function (linkfile, pluginPaths) {\n      const type = fs.readFileSync(linkfile).toString()\n      const pathParts = linkfile.split(path.sep)\n      const name = pathParts[(pathParts.length - 1)].split('.')[0]\n      const pathsToTry = pluginPaths.slice(0)\n      let pluginRoot\n\n      // TODO: always also try the local destination's `node_modules` to allow for nested plugins\n      // This might be a security risk without requiring explicit sourcing\n\n      pathsToTry.forEach((pluginPath) => {\n        let pluginPathAttempt = path.normalize(pluginPath + path.sep + name)\n        try {\n          let stats = fs.lstatSync(pluginPathAttempt)\n          if (!pluginRoot && (stats.isDirectory() || stats.isSymbolicLink())) { pluginRoot = pluginPathAttempt }\n        } catch (e) { }\n      })\n\n      if (!pluginRoot) { return false }\n      let pluginSection = path.normalize(pluginRoot + path.sep + type)\n      return pluginSection\n    }\n\n    // //////////////////////////////////////////////////////////////////////////\n    // object Clone\n    api.utils.objClone = function (obj) {\n      return Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyNames(obj).reduce((memo, name) => {\n        return (memo[name] = Object.getOwnPropertyDescriptor(obj, name)) && memo\n      }, {}))\n    }\n\n    // //////////////////////////////////////////////////////////////////////////\n    // attempt to collapse this object to an array; ie: {\"0\": \"a\", \"1\": \"b\"}\n    api.utils.collapseObjectToArray = function (obj) {\n      try {\n        const keys = Object.keys(obj)\n        if (keys.length < 1) { return false }\n        if (keys[0] !== '0') { return false }\n        if (keys[(keys.length - 1)] !== String(keys.length - 1)) { return false }\n\n        let arr = []\n        for (let i in keys) {\n          let key = keys[i]\n          if (String(parseInt(key)) !== key) { return false } else { arr.push(obj[key]) }\n        }\n\n        return arr\n      } catch (e) {\n        return false\n      }\n    }\n\n    // //////////////////////////////////////////////////////////////////////////\n    // get this servers external interface\n    api.utils.getExternalIPAddress = function () {\n      const os = require('os')\n      const ifaces = os.networkInterfaces()\n      let ip = false\n      for (let dev in ifaces) {\n        ifaces[dev].forEach((details) => {\n          if (details.family === 'IPv4' && details.address !== '127.0.0.1') {\n            ip = details.address\n          }\n        })\n      }\n      return ip\n    }\n\n    // //////////////////////////////////////////////////////////////////////////\n    // cookie parse from headers of http(s) requests\n    api.utils.parseCookies = function (req) {\n      let cookies = {}\n      if (req.headers.cookie) {\n        req.headers.cookie.split(';').forEach((cookie) => {\n          let parts = cookie.split('=')\n          cookies[parts[0].trim()] = (parts[1] || '').trim()\n        })\n      }\n      return cookies\n    }\n\n    // //////////////////////////////////////////////////////////////////////////\n    // parse an IPv6 address\n    // https://github.com/actionhero/actionhero/issues/275 && https://github.com/nullivex\n    api.utils.parseIPv6URI = function (addr) {\n      let host = '::1'\n      let port = '80'\n      let regexp = new RegExp(/\\[([0-9a-f:]+)]:([0-9]{1,5})/)\n      // if we have brackets parse them and find a port\n      if (addr.indexOf('[') > -1 && addr.indexOf(']') > -1) {\n        let res = regexp.exec(addr)\n        if (res === null) {\n          throw new Error('failed to parse address')\n        }\n        host = res[1]\n        port = res[2]\n      } else {\n        host = addr\n      }\n      return {host: host, port: parseInt(port, 10)}\n    }\n\n    // //////////////////////////////////////////////////////////////////////////\n    // Check on how long the event loop is blocked for\n    api.utils.eventLoopDelay = function (itterations, callback) {\n      let intervalJobs = []\n      let intervalTimes = []\n\n      if (!itterations) { return callback(new Error('itterations is required')) }\n\n      let i = 0\n      while (i < itterations) {\n        intervalJobs.push((intervalDone) => {\n          let start = process.hrtime()\n          process.nextTick(() => {\n            let delta = process.hrtime(start)\n            let ms = (delta[0] * 1000) + (delta[1] / 1000000)\n            intervalTimes.push(ms)\n            intervalDone()\n          })\n        })\n        i++\n      }\n\n      async.series(intervalJobs, function () {\n        let sum = 0\n        intervalTimes.forEach((t) => { sum += t })\n        let avg = Math.round(sum / intervalTimes.length * 10000) / 1000\n        return callback(null, avg)\n      })\n    }\n\n    // //////////////////////////////////////////////////////////////////////////\n    // Sort Global Middleware\n    api.utils.sortGlobalMiddleware = function (globalMiddlewareList, middleware) {\n      globalMiddlewareList.sort((a, b) => {\n        if (middleware[a].priority > middleware[b].priority) {\n          return 1\n        } else {\n          return -1\n        }\n      })\n    }\n\n    // //////////////////////////////////////////////////////////////////////////\n    // File utils\n    api.utils.dirExists = function (dir) {\n      try {\n        let stats = fs.lstatSync(dir)\n        return (stats.isDirectory() || stats.isSymbolicLink())\n      } catch (e) { return false }\n    }\n\n    api.utils.fileExists = function (file) {\n      try {\n        let stats = fs.lstatSync(file)\n        return (stats.isFile() || stats.isSymbolicLink())\n      } catch (e) { return false }\n    }\n\n    api.utils.createDirSafely = function (dir) {\n      if (api.utils.dirExists(dir)) {\n        api.log([' - directory \\'%s\\' already exists, skipping', path.normalize(dir)], 'alert')\n      } else {\n        api.log([' - creating directory \\'%s\\'', path.normalize(dir)])\n        fs.mkdirSync(path.normalize(dir), '0766')\n      }\n    }\n\n    api.utils.createFileSafely = function (file, data, overwrite) {\n      if (api.utils.fileExists(file) && !overwrite) {\n        api.log([' - file \\'%s\\' already exists, skipping', path.normalize(file)], 'alert')\n      } else {\n        if (overwrite && api.utils.fileExists(file)) {\n          api.log([' - overwritten file \\'%s\\'', path.normalize(file)])\n        } else {\n          api.log([' - wrote file \\'%s\\'', path.normalize(file)])\n        }\n        fs.writeFileSync(path.normalize(file), data)\n      }\n    }\n\n    api.utils.createLinkfileSafely = function (filePath, type, refrence) {\n      if (api.utils.fileExists(filePath)) {\n        api.log([' - link file \\'%s\\' already exists, skipping', filePath], 'alert')\n      } else {\n        api.log([' - creating linkfile \\'%s\\'', filePath])\n        fs.writeFileSync(filePath, type)\n      }\n    }\n\n    api.utils.removeLinkfileSafely = function (filePath, type, refrence) {\n      if (!api.utils.fileExists(filePath)) {\n        api.log([' - link file \\'%s\\' doesn\\'t exist, skipping', filePath], 'alert')\n      } else {\n        api.log([' - removing linkfile \\'%s\\'', filePath])\n        fs.unlinkSync(filePath)\n      }\n    }\n\n    api.utils.createSymlinkSafely = function (destination, source) {\n      if (api.utils.dirExists(destination)) {\n        api.log([' - symbolic link \\'%s\\' already exists, skipping', destination], 'alert')\n      } else {\n        api.log([' - creating symbolic link \\'%s\\' => \\'%s\\'', destination, source])\n        fs.symlinkSync(source, destination, 'dir')\n      }\n    }\n\n    next()\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-actionhero/node_modules/actionhero/servers/socket.js":"'use strict'\n\nconst net = require('net')\nconst tls = require('tls')\n\nconst initialize = function (api, options, next) {\n  // ////////\n  // INIT //\n  // ////////\n\n  const type = 'socket'\n  const attributes = {\n    canChat: true,\n    logConnections: true,\n    logExits: true,\n    pendingShutdownWaitLimit: 5000,\n    sendWelcomeMessage: true,\n    verbs: [\n      'quit',\n      'exit',\n      'documentation',\n      'paramAdd',\n      'paramDelete',\n      'paramView',\n      'paramsView',\n      'paramsDelete',\n      'roomAdd',\n      'roomLeave',\n      'roomView',\n      'detailsView',\n      'say'\n    ]\n  }\n\n  const server = new api.GenericServer(type, options, attributes)\n\n  // ////////////////////\n  // REQUIRED METHODS //\n  // ////////////////////\n\n  server.start = function (next) {\n    if (options.secure === false) {\n      server.server = net.createServer(api.config.servers.socket.serverOptions, (rawConnection) => {\n        handleConnection(rawConnection)\n      })\n    } else {\n      server.server = tls.createServer(api.config.servers.socket.serverOptions, (rawConnection) => {\n        handleConnection(rawConnection)\n      })\n    }\n\n    server.server.on('error', (e) => {\n      return next(new Error('Cannot start socket server @ ' + options.bindIP + ':' + options.port + ' => ' + e.message))\n    })\n\n    server.server.listen(options.port, options.bindIP, () => {\n      process.nextTick(next)\n    })\n  }\n\n  server.stop = function (next) {\n    gracefulShutdown(next)\n  }\n\n  server.sendMessage = function (connection, message, messageCount) {\n    if (message.error) {\n      message.error = api.config.errors.serializers.servers.socket(message.error)\n    }\n\n    if (connection.respondingTo) {\n      message.messageCount = messageCount\n      connection.respondingTo = null\n    } else if (message.context === 'response') {\n      if (messageCount) {\n        message.messageCount = messageCount\n      } else {\n        message.messageCount = connection.messageCount\n      }\n    }\n    try {\n      connection.rawConnection.write(JSON.stringify(message) + '\\r\\n')\n    } catch (e) {\n      api.log(['socket write error: %s', e], 'error')\n    }\n  }\n\n  server.goodbye = function (connection) {\n    try {\n      connection.rawConnection.end(JSON.stringify({status: connection.localize(api.config.servers.socket.goodbyeMessage), context: 'api'}) + '\\r\\n')\n    } catch (e) {}\n  }\n\n  server.sendFile = function (connection, error, fileStream) {\n    if (error) {\n      server.sendMessage(connection, error, connection.messageCount)\n    } else {\n      fileStream.pipe(connection.rawConnection, {end: false})\n    }\n  }\n\n  // //////////\n  // EVENTS //\n  // //////////\n\n  server.on('connection', function (connection) {\n    connection.params = {}\n\n    const parseLine = function (line) {\n      if (api.config.servers.socket.maxDataLength > 0) {\n        let blen = Buffer.byteLength(line, 'utf8')\n        if (blen > api.config.servers.socket.maxDataLength) {\n          let error = api.config.errors.dataLengthTooLarge(api.config.servers.socket.maxDataLength, blen)\n          server.log(error, 'error')\n          return server.sendMessage(connection, {status: 'error', error: error, context: 'response'})\n        }\n      }\n      if (line.length > 0) {\n        // increment at the start of the request so that responses can be caught in order on the client\n        // this is not handled by the GenericServer\n        connection.messageCount++\n        parseRequest(connection, line)\n      }\n    }\n\n    connection.rawConnection.on('data', (chunk) => {\n      if (checkBreakChars(chunk)) {\n        connection.destroy()\n      } else {\n        // Replace all carriage returns with newlines.\n        connection.rawConnection.socketDataString += chunk.toString('utf-8').replace(/\\r/g, '\\n')\n        let index\n        let d = String(api.config.servers.socket.delimiter)\n\n        while ((index = connection.rawConnection.socketDataString.indexOf(d)) > -1) {\n          let data = connection.rawConnection.socketDataString.slice(0, index)\n          connection.rawConnection.socketDataString = connection.rawConnection.socketDataString.slice(index + d.length)\n          data.split(d).forEach(parseLine)\n        }\n      }\n    })\n\n    connection.rawConnection.on('end', () => {\n      if (connection.destroyed !== true) {\n        try { connection.rawConnection.end() } catch (e) {}\n        connection.destroy()\n      }\n    })\n\n    connection.rawConnection.on('error', (e) => {\n      if (connection.destroyed !== true) {\n        server.log('socket error: ' + e, 'error')\n        try { connection.rawConnection.end() } catch (e) {}\n        connection.destroy()\n      }\n    })\n  })\n\n  server.on('actionComplete', (data) => {\n    if (data.toRender === true) {\n      data.response.context = 'response'\n      server.sendMessage(data.connection, data.response, data.messageCount)\n    }\n  })\n\n  // ///////////\n  // HELPERS //\n  // ///////////\n\n  const parseRequest = function (connection, line) {\n    let words = line.split(' ')\n    let verb = words.shift()\n    if (verb === 'file') {\n      if (words.length > 0) {\n        connection.params.file = words[0]\n      }\n      server.processFile(connection)\n    } else {\n      connection.verbs(verb, words, (error, data) => {\n        if (!error) {\n          server.sendMessage(connection, {status: 'OK', context: 'response', data: data})\n        } else if (error.toString().match('verb not found or not allowed')) {\n          // check for and attempt to check single-use params\n          try {\n            let requestHash = JSON.parse(line)\n            if (requestHash.params !== undefined) {\n              connection.params = {}\n              for (let v in requestHash.params) {\n                connection.params[v] = requestHash.params[v]\n              }\n            }\n            if (requestHash.action) {\n              connection.params.action = requestHash.action\n            }\n          } catch (e) {\n            connection.params.action = verb\n          }\n          connection.error = null\n          connection.response = {}\n          server.processAction(connection)\n        } else {\n          server.sendMessage(connection, {status: error.toString().replace(/^Error:\\s/, ''), context: 'response', data: data})\n        }\n      })\n    }\n  }\n\n  const handleConnection = function (rawConnection) {\n    if (api.config.servers.socket.setKeepAlive === true) {\n      rawConnection.setKeepAlive(true)\n    }\n    rawConnection.socketDataString = ''\n    server.buildConnection({\n      rawConnection: rawConnection,\n      remoteAddress: rawConnection.remoteAddress,\n      remotePort: rawConnection.remotePort\n    }) // will emit 'connection'\n  }\n\n  // I check for ctrl+c in the stream\n  const checkBreakChars = function (chunk) {\n    let found = false\n    let hexChunk = chunk.toString('hex', 0, chunk.length)\n    if (hexChunk === 'fff4fffd06') {\n      found = true // CTRL + C\n    } else if (hexChunk === '04') {\n      found = true // CTRL + D\n    }\n    return found\n  }\n\n  const gracefulShutdown = function (next, alreadyShutdown) {\n    if (!alreadyShutdown || alreadyShutdown === false) {\n      if (server.server) { server.server.close() }\n    }\n    let pendingConnections = 0\n    server.connections().forEach((connection) => {\n      if (connection.pendingActions === 0) {\n        connection.destroy()\n      } else {\n        pendingConnections++\n        if (!connection.rawConnection.shutDownTimer) {\n          connection.rawConnection.shutDownTimer = setTimeout(() => {\n            connection.destroy()\n          }, attributes.pendingShutdownWaitLimit)\n        }\n      }\n    })\n    if (pendingConnections > 0) {\n      server.log('waiting on shutdown, there are still ' + pendingConnections + ' connected clients waiting on a response', 'notice')\n      setTimeout(() => {\n        gracefulShutdown(next, true)\n      }, 1000)\n    } else if (typeof next === 'function') { next() }\n  }\n\n  next(server)\n}\n\n// ///////////////////////////////////////////////////////////////////\n// exports\nexports.initialize = initialize\n","/home/travis/build/npmtest/node-npmtest-actionhero/node_modules/actionhero/servers/web.js":"'use strict'\n\nconst url = require('url')\nconst qs = require('qs')\nconst fs = require('fs')\nconst path = require('path')\nconst zlib = require('zlib')\nconst formidable = require('formidable')\nconst browserFingerprint = require('browser_fingerprint')\nconst Mime = require('mime')\nconst uuid = require('uuid')\nconst etag = require('etag')\n\nconst initialize = function (api, options, next) {\n  // ////////\n  // INIT //\n  // ////////\n\n  const type = 'web'\n  const attributes = {\n    canChat: false,\n    logConnections: false,\n    logExits: false,\n    sendWelcomeMessage: false,\n    verbs: [\n      // no verbs for connections of this type, as they are to be very short-lived\n    ]\n  }\n\n  const server = new api.GenericServer(type, options, attributes)\n\n  if (['api', 'file'].indexOf(api.config.servers.web.rootEndpointType) < 0) {\n    throw new Error('api.config.servers.web.rootEndpointType can only be \\'api\\' or \\'file\\'')\n  }\n\n  // ////////////////////\n  // REQUIRED METHODS //\n  // ////////////////////\n\n  server.start = function (next) {\n    if (options.secure === false) {\n      const http = require('http')\n      server.server = http.createServer((req, res) => {\n        handleRequest(req, res)\n      })\n    } else {\n      const https = require('https')\n      server.server = https.createServer(api.config.servers.web.serverOptions, (req, res) => {\n        handleRequest(req, res)\n      })\n    }\n\n    let bootAttempts = 0\n    server.server.on('error', (e) => {\n      bootAttempts++\n      if (bootAttempts < api.config.servers.web.bootAttempts) {\n        server.log('cannot boot web server; trying again [' + String(e) + ']', 'error')\n        if (bootAttempts === 1) { cleanSocket(options.bindIP, options.port) }\n        setTimeout(() => {\n          server.log('attempting to boot again..')\n          server.server.listen(options.port, options.bindIP)\n        }, 1000)\n      } else {\n        return next(new Error('cannot start web server @ ' + options.bindIP + ':' + options.port + ' => ' + e.message))\n      }\n    })\n\n    server.server.listen(options.port, options.bindIP, () => {\n      chmodSocket(options.bindIP, options.port)\n      next()\n    })\n  }\n\n  server.stop = function (next) {\n    if (server.server) { server.server.close() }\n    process.nextTick(next)\n  }\n\n  server.sendMessage = function (connection, message) {\n    let stringResponse = ''\n    if (connection.rawConnection.method !== 'HEAD') {\n      stringResponse = String(message)\n    }\n\n    cleanHeaders(connection)\n    const headers = connection.rawConnection.responseHeaders\n    const responseHttpCode = parseInt(connection.rawConnection.responseHttpCode)\n\n    server.sendWithCompression(connection, responseHttpCode, headers, stringResponse)\n  }\n\n  server.sendFile = function (connection, error, fileStream, mime, length, lastModified) {\n    let foundCacheControl = false\n    let ifModifiedSince\n    let reqHeaders\n\n    connection.rawConnection.responseHeaders.forEach((pair) => {\n      if (pair[0].toLowerCase() === 'cache-control') { foundCacheControl = true }\n    })\n\n    connection.rawConnection.responseHeaders.push(['Content-Type', mime])\n\n    if (fileStream) {\n      if (!foundCacheControl) { connection.rawConnection.responseHeaders.push(['Cache-Control', 'max-age=' + api.config.servers.web.flatFileCacheDuration + ', must-revalidate, public']) }\n    }\n    if (fileStream && !api.config.servers.web.enableEtag) {\n      if (lastModified) { connection.rawConnection.responseHeaders.push(['Last-Modified', new Date(lastModified).toUTCString()]) }\n    }\n\n    cleanHeaders(connection)\n    const headers = connection.rawConnection.responseHeaders\n    reqHeaders = connection.rawConnection.req.headers\n\n    let sendRequestResult = function () {\n      let responseHttpCode = parseInt(connection.rawConnection.responseHttpCode, 10)\n      if (error) {\n        server.sendWithCompression(connection, responseHttpCode, headers, String(error))\n      } else if (responseHttpCode !== 304) {\n        server.sendWithCompression(connection, responseHttpCode, headers, null, fileStream, length)\n      } else {\n        connection.rawConnection.res.writeHead(responseHttpCode, transformHeaders(headers))\n        connection.rawConnection.res.end()\n        connection.destroy()\n      }\n    }\n\n    if (error) {\n      connection.rawConnection.responseHttpCode = 404\n      return sendRequestResult()\n    }\n\n    if (reqHeaders['if-modified-since']) {\n      ifModifiedSince = new Date(reqHeaders['if-modified-since'])\n      lastModified.setMilliseconds(0)\n      if (lastModified <= ifModifiedSince) { connection.rawConnection.responseHttpCode = 304 }\n      return sendRequestResult()\n    }\n\n    if (api.config.servers.web.enableEtag && fileStream && fileStream.path) {\n      fs.stat(fileStream.path, (error, filestats) => {\n        if (error) {\n          server.log('Error receving file statistics: ' + String(error), 'error')\n          return sendRequestResult()\n        }\n        const fileEtag = etag(filestats, {weak: true})\n        connection.rawConnection.responseHeaders.push(['ETag', fileEtag])\n        let noneMatchHeader = reqHeaders['if-none-match']\n        let cacheCtrlHeader = reqHeaders['cache-control']\n        let noCache = false\n        let etagMatches\n        // check for no-cache cache request directive\n        if (cacheCtrlHeader && cacheCtrlHeader.indexOf('no-cache') !== -1) {\n          noCache = true\n        }\n        // parse if-none-match\n        if (noneMatchHeader) { noneMatchHeader = noneMatchHeader.split(/ *, */) }\n        // if-none-match\n        if (noneMatchHeader) {\n          etagMatches = noneMatchHeader.some((match) => {\n            return match === '*' || match === fileEtag || match === 'W/' + fileEtag\n          })\n        }\n        if (etagMatches && !noCache) {\n          connection.rawConnection.responseHttpCode = 304\n        }\n        sendRequestResult()\n      })\n    } else {\n      sendRequestResult()\n    }\n  }\n\n  server.sendWithCompression = function (connection, responseHttpCode, headers, stringResponse, fileStream, fileLength) {\n    let acceptEncoding = connection.rawConnection.req.headers['accept-encoding']\n    let compressor\n    let stringEncoder\n    if (!acceptEncoding) { acceptEncoding = '' }\n\n    // Note: this is not a conformant accept-encoding parser.\n    // https://nodejs.org/api/zlib.html#zlib_zlib_createinflate_options\n    // See http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.3\n    if (api.config.servers.web.compress === true) {\n      let gzipMatch = acceptEncoding.match(/\\bgzip\\b/)\n      let deflateMatch = acceptEncoding.match(/\\bdeflate\\b/)\n      if ((gzipMatch && !deflateMatch) || (gzipMatch && deflateMatch && gzipMatch.index < deflateMatch.index)) {\n        headers.push(['Content-Encoding', 'gzip'])\n        compressor = zlib.createGzip()\n        stringEncoder = zlib.gzip\n      } else if ((!gzipMatch && deflateMatch) || (gzipMatch && deflateMatch && deflateMatch.index < gzipMatch.index)) {\n        headers.push(['Content-Encoding', 'deflate'])\n        compressor = zlib.createDeflate()\n        stringEncoder = zlib.deflate\n      }\n    }\n\n    // the 'finish' event deontes a successful transfer\n    connection.rawConnection.res.on('finish', () => {\n      connection.destroy()\n    })\n\n    // the 'close' event deontes a failed transfer, but it is probably the client's fault\n    connection.rawConnection.res.on('close', () => {\n      connection.destroy()\n    })\n\n    if (fileStream) {\n      if (compressor) {\n        // headers.push(['Content-Length', fileLength]); // TODO\n        connection.rawConnection.res.writeHead(responseHttpCode, transformHeaders(headers))\n        fileStream.pipe(compressor).pipe(connection.rawConnection.res)\n      } else {\n        // file length might be null if we don't know how long the stream is\n        if (fileLength) {\n          headers.push(['Content-Length', fileLength])\n        }\n        connection.rawConnection.res.writeHead(responseHttpCode, transformHeaders(headers))\n        fileStream.pipe(connection.rawConnection.res)\n      }\n    } else {\n      if (stringEncoder) {\n        stringEncoder(stringResponse, (error, zippedString) => {\n          if (error) { console.error(error) }\n          headers.push(['Content-Length', zippedString.length])\n          connection.rawConnection.res.writeHead(responseHttpCode, transformHeaders(headers))\n          connection.rawConnection.res.end(zippedString)\n        })\n      } else {\n        headers.push(['Content-Length', Buffer.byteLength(stringResponse)])\n        connection.rawConnection.res.writeHead(responseHttpCode, transformHeaders(headers))\n        connection.rawConnection.res.end(stringResponse)\n      }\n    }\n  }\n\n  server.goodbye = function () {\n    // disconnect handlers\n  }\n\n  // //////////\n  // EVENTS //\n  // //////////\n\n  server.on('connection', (connection) => {\n    determineRequestParams(connection, (requestMode) => {\n      if (requestMode === 'api') {\n        server.processAction(connection)\n      } else if (requestMode === 'file') {\n        server.processFile(connection)\n      } else if (requestMode === 'options') {\n        respondToOptions(connection)\n      } else if (requestMode === 'trace') {\n        respondToTrace(connection)\n      }\n    })\n  })\n\n  server.on('actionComplete', (data) => {\n    completeResponse(data)\n  })\n\n  // ///////////\n  // HELPERS //\n  // ///////////\n\n  const handleRequest = function (req, res) {\n    browserFingerprint.fingerprint(req, api.config.servers.web.fingerprintOptions, (error, fingerprint, elementHash, cookieHash) => {\n      if (error) throw error\n\n      let responseHeaders = []\n      let cookies = api.utils.parseCookies(req)\n      let responseHttpCode = 200\n      let method = req.method.toUpperCase()\n      let parsedURL = url.parse(req.url, true)\n      let i\n      for (i in cookieHash) {\n        responseHeaders.push([i, cookieHash[i]])\n      }\n\n      // https://github.com/actionhero/actionhero/issues/189\n      responseHeaders.push(['Content-Type', 'application/json; charset=utf-8'])\n\n      for (i in api.config.servers.web.httpHeaders) {\n        if (api.config.servers.web.httpHeaders[i]) {\n          responseHeaders.push([i, api.config.servers.web.httpHeaders[i]])\n        }\n      }\n\n      let remoteIP = req.connection.remoteAddress\n      let remotePort = req.connection.remotePort\n\n      // helpers for unix socket bindings with no forward\n      if (!remoteIP && !remotePort) {\n        remoteIP = '0.0.0.0'\n        remotePort = '0'\n      }\n\n      if (req.headers['x-forwarded-for']) {\n        let parts\n        let forwardedIp = req.headers['x-forwarded-for'].split(',')[0]\n        if (forwardedIp.indexOf('.') >= 0 || (forwardedIp.indexOf('.') < 0 && forwardedIp.indexOf(':') < 0)) {\n          // IPv4\n          forwardedIp = forwardedIp.replace('::ffff:', '') // remove any IPv6 information, ie: '::ffff:127.0.0.1'\n          parts = forwardedIp.split(':')\n          if (parts[0]) { remoteIP = parts[0] }\n          if (parts[1]) { remotePort = parts[1] }\n        } else {\n          // IPv6\n          parts = api.utils.parseIPv6URI(forwardedIp)\n          if (parts.host) { remoteIP = parts.host }\n          if (parts.port) { remotePort = parts.port }\n        }\n\n        if (req.headers['x-forwarded-port']) {\n          remotePort = req.headers['x-forwarded-port']\n        }\n      }\n\n      if (api.config.servers.web.allowedRequestHosts && api.config.servers.web.allowedRequestHosts.length > 0) {\n        let guess = 'http://'\n        if (options.secure) { guess = 'https://' }\n        let fullRequestHost = (req.headers['x-forwarded-proto'] ? req.headers['x-forwarded-proto'] + '://' : guess) + req.headers.host\n        if (api.config.servers.web.allowedRequestHosts.indexOf(fullRequestHost) < 0) {\n          let newHost = api.config.servers.web.allowedRequestHosts[0]\n          res.statusCode = 302\n          res.setHeader('Location', newHost + req.url)\n          return res.end(`You are being redirected to ${newHost + req.url}\\r\\n`)\n        }\n      }\n\n      server.buildConnection({\n        // will emit 'connection'\n        rawConnection: {\n          req: req,\n          res: res,\n          params: {},\n          method: method,\n          cookies: cookies,\n          responseHeaders: responseHeaders,\n          responseHttpCode: responseHttpCode,\n          parsedURL: parsedURL\n        },\n        id: fingerprint + '-' + uuid.v4(),\n        fingerprint: fingerprint,\n        remoteAddress: remoteIP,\n        remotePort: remotePort\n      })\n    })\n  }\n\n  const completeResponse = function (data) {\n    if (data.toRender === true) {\n      if (api.config.servers.web.metadataOptions.serverInformation && typeof data.response !== 'string') {\n        const stopTime = new Date().getTime()\n        data.response.serverInformation = {\n          serverName: api.config.general.serverName,\n          apiVersion: api.config.general.apiVersion,\n          requestDuration: (stopTime - data.connection.connectedAt),\n          currentTime: stopTime\n        }\n      }\n\n      if (api.config.servers.web.metadataOptions.requesterInformation && typeof data.response !== 'string') {\n        data.response.requesterInformation = buildRequesterInformation(data.connection)\n      }\n\n      if (data.response.error) {\n        if (api.config.servers.web.returnErrorCodes === true && data.connection.rawConnection.responseHttpCode === 200) {\n          if (data.actionStatus === 'unknown_action') {\n            data.connection.rawConnection.responseHttpCode = 404\n          } else if (data.actionStatus === 'missing_params') {\n            data.connection.rawConnection.responseHttpCode = 422\n          } else if (data.actionStatus === 'server_error') {\n            data.connection.rawConnection.responseHttpCode = 500\n          } else {\n            data.connection.rawConnection.responseHttpCode = 400\n          }\n        }\n      }\n\n      if (\n          !data.response.error &&\n          data.action &&\n          data.params.apiVersion &&\n          api.actions.actions[data.params.action][data.params.apiVersion].matchExtensionMimeType === true &&\n          data.connection.extension\n        ) {\n        data.connection.rawConnection.responseHeaders.push(['Content-Type', Mime.lookup(data.connection.extension)])\n      }\n\n      if (data.response.error) {\n        data.response.error = api.config.errors.serializers.servers.web(data.response.error)\n      }\n\n      let stringResponse = ''\n\n      if (extractHeader(data.connection, 'Content-Type').match(/json/)) {\n        stringResponse = JSON.stringify(data.response, null, api.config.servers.web.padding)\n        if (data.params.callback) {\n          data.connection.rawConnection.responseHeaders.push(['Content-Type', 'application/javascript'])\n          stringResponse = callbackHtmlEscape(data.connection.params.callback) + '(' + stringResponse + ');'\n        }\n      } else {\n        stringResponse = data.response\n      }\n\n      server.sendMessage(data.connection, stringResponse)\n    }\n  }\n\n  const extractHeader = function (connection, match) {\n    let i = connection.rawConnection.responseHeaders.length - 1\n    while (i >= 0) {\n      if (connection.rawConnection.responseHeaders[i][0].toLowerCase() === match.toLowerCase()) {\n        return connection.rawConnection.responseHeaders[i][1]\n      }\n      i--\n    }\n    return null\n  }\n\n  const respondToOptions = function (connection) {\n    if (!api.config.servers.web.httpHeaders['Access-Control-Allow-Methods'] && !extractHeader(connection, 'Access-Control-Allow-Methods')) {\n      const methods = 'HEAD, GET, POST, PUT, DELETE, OPTIONS, TRACE'\n      connection.rawConnection.responseHeaders.push(['Access-Control-Allow-Methods', methods])\n    }\n    if (!api.config.servers.web.httpHeaders['Access-Control-Allow-Origin'] && !extractHeader(connection, 'Access-Control-Allow-Origin')) {\n      const origin = '*'\n      connection.rawConnection.responseHeaders.push(['Access-Control-Allow-Origin', origin])\n    }\n    server.sendMessage(connection, '')\n  }\n\n  const respondToTrace = function (connection) {\n    const data = buildRequesterInformation(connection)\n    const stringResponse = JSON.stringify(data, null, api.config.servers.web.padding)\n    server.sendMessage(connection, stringResponse)\n  }\n\n  const determineRequestParams = function (connection, callback) {\n    // determine file or api request\n    let requestMode = api.config.servers.web.rootEndpointType\n    let pathname = connection.rawConnection.parsedURL.pathname\n    let pathParts = pathname.split('/')\n    let matcherLength\n    let i\n    while (pathParts[0] === '') { pathParts.shift() }\n    if (pathParts[pathParts.length - 1] === '') { pathParts.pop() }\n\n    if (pathParts[0] && pathParts[0] === api.config.servers.web.urlPathForActions) {\n      requestMode = 'api'\n      pathParts.shift()\n    } else if (pathParts[0] && pathParts[0] === api.config.servers.web.urlPathForFiles) {\n      requestMode = 'file'\n      pathParts.shift()\n    } else if (pathParts[0] && pathname.indexOf(api.config.servers.web.urlPathForActions) === 0) {\n      requestMode = 'api'\n      matcherLength = api.config.servers.web.urlPathForActions.split('/').length\n      for (i = 0; i < (matcherLength - 1); i++) { pathParts.shift() }\n    } else if (pathParts[0] && pathname.indexOf(api.config.servers.web.urlPathForFiles) === 0) {\n      requestMode = 'file'\n      matcherLength = api.config.servers.web.urlPathForFiles.split('/').length\n      for (i = 0; i < (matcherLength - 1); i++) { pathParts.shift() }\n    }\n\n    let extensionParts = connection.rawConnection.parsedURL.pathname.split('.')\n    if (extensionParts.length > 1) {\n      connection.extension = extensionParts[(extensionParts.length - 1)]\n    }\n\n    // OPTIONS\n    if (connection.rawConnection.method === 'OPTIONS') {\n      requestMode = 'options'\n      callback(requestMode)\n\n    // API\n    } else if (requestMode === 'api') {\n      if (connection.rawConnection.method === 'TRACE') { requestMode = 'trace' }\n      let search = connection.rawConnection.parsedURL.search.slice(1)\n      fillParamsFromWebRequest(connection, qs.parse(search, api.config.servers.web.queryParseOptions))\n      connection.rawConnection.params.query = connection.rawConnection.parsedURL.query\n      if (\n          connection.rawConnection.method !== 'GET' &&\n          connection.rawConnection.method !== 'HEAD' &&\n          (\n            connection.rawConnection.req.headers['content-type'] ||\n            connection.rawConnection.req.headers['Content-Type']\n          )\n      ) {\n        connection.rawConnection.form = new formidable.IncomingForm()\n        for (i in api.config.servers.web.formOptions) {\n          connection.rawConnection.form[i] = api.config.servers.web.formOptions[i]\n        }\n        connection.rawConnection.form.parse(connection.rawConnection.req, (error, fields, files) => {\n          if (error) {\n            server.log('error processing form: ' + String(error), 'error')\n            connection.error = new Error('There was an error processing this form.')\n          } else {\n            connection.rawConnection.params.body = fields\n            connection.rawConnection.params.files = files\n            fillParamsFromWebRequest(connection, files)\n            fillParamsFromWebRequest(connection, fields)\n          }\n          if (api.config.servers.web.queryRouting !== true) { connection.params.action = null }\n          api.routes.processRoute(connection, pathParts)\n          callback(requestMode)\n        })\n      } else {\n        if (api.config.servers.web.queryRouting !== true) { connection.params.action = null }\n        api.routes.processRoute(connection, pathParts)\n        callback(requestMode)\n      }\n\n    // FILE\n    } else if (requestMode === 'file') {\n      api.routes.processRoute(connection, pathParts)\n      if (!connection.params.file) {\n        connection.params.file = pathParts.join(path.sep)\n      }\n      if (connection.params.file === '' || connection.params.file[connection.params.file.length - 1] === '/') {\n        connection.params.file = connection.params.file + api.config.general.directoryFileType\n      }\n      try {\n        connection.params.file = decodeURIComponent(connection.params.file)\n      } catch (e) {\n        connection.error = new Error('There was an error decoding URI: ' + e)\n      }\n      callback(requestMode)\n    }\n  }\n\n  const fillParamsFromWebRequest = function (connection, varsHash) {\n    // helper for JSON posts\n    let collapsedVarsHash = api.utils.collapseObjectToArray(varsHash)\n    if (collapsedVarsHash !== false) {\n      varsHash = {payload: collapsedVarsHash} // post was an array, lets call it \"payload\"\n    }\n\n    for (let v in varsHash) {\n      connection.params[v] = varsHash[v]\n    }\n  }\n\n  const transformHeaders = function (headersArray) {\n    return headersArray.reduce((headers, currentHeader) => {\n      let currentHeaderKey = currentHeader[0].toLowerCase()\n      // we have a set-cookie, let's see what we have to do\n      if (currentHeaderKey === 'set-cookie') {\n        if (headers[currentHeaderKey]) {\n          headers[currentHeaderKey].push(currentHeader[1])\n        } else {\n          headers[currentHeaderKey] = [currentHeader[1]]\n        }\n      } else {\n        headers[currentHeaderKey] = currentHeader[1]\n      }\n\n      return headers\n    }, {})\n  }\n\n  const buildRequesterInformation = function (connection) {\n    let requesterInformation = {\n      id: connection.id,\n      fingerprint: connection.fingerprint,\n      remoteIP: connection.remoteIP,\n      receivedParams: {}\n    }\n\n    for (let p in connection.params) {\n      if (api.config.general.disableParamScrubbing === true || api.params.postVariables.indexOf(p) >= 0) {\n        requesterInformation.receivedParams[p] = connection.params[p]\n      }\n    }\n\n    return requesterInformation\n  }\n\n  const cleanHeaders = function (connection) {\n    const originalHeaders = connection.rawConnection.responseHeaders.reverse()\n    let foundHeaders = []\n    let cleanedHeaders = []\n    for (let i in originalHeaders) {\n      let key = originalHeaders[i][0]\n      let value = originalHeaders[i][1]\n      if (foundHeaders.indexOf(key.toLowerCase()) >= 0 && key.toLowerCase().indexOf('set-cookie') < 0) {\n        // ignore, it's a duplicate\n      } else if (connection.rawConnection.method === 'HEAD' && key === 'Transfer-Encoding') {\n        // ignore, we can't send this header for HEAD requests\n      } else {\n        foundHeaders.push(key.toLowerCase())\n        cleanedHeaders.push([key, value])\n      }\n    }\n    connection.rawConnection.responseHeaders = cleanedHeaders\n  }\n\n  const cleanSocket = function (bindIP, port) {\n    if (!bindIP && typeof port === 'string' && port.indexOf('/') >= 0) {\n      fs.unlink(port, (error) => {\n        if (error) {\n          server.log('cannot remove stale socket @' + port + ' : ' + error)\n        } else {\n          server.log('removed stale unix socket @ ' + port)\n        }\n      })\n    }\n  }\n\n  const chmodSocket = function (bindIP, port) {\n    if (!bindIP && typeof port === 'string' && port.indexOf('/') >= 0) {\n      fs.chmodSync(port, '0777')\n    }\n  }\n\n  next(server)\n}\n\nfunction callbackHtmlEscape (str) {\n  return str\n    .replace(/&/g, '&amp;')\n    .replace(/\"/g, '&quot;')\n    .replace(/'/g, '&#39;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(/\\)/g, '')\n    .replace(/\\(/g, '')\n}\n\n// ///////////////////////////////////////////////////////////////////\n// exports\nexports.initialize = initialize\n","/home/travis/build/npmtest/node-npmtest-actionhero/node_modules/actionhero/servers/websocket.js":"'use strict'\n\nconst Primus = require('primus')\nconst UglifyJS = require('uglify-js')\nconst fs = require('fs')\nconst path = require('path')\nconst util = require('util')\nconst browserFingerprint = require('browser_fingerprint')\n\nconst initialize = function (api, options, next) {\n  // ////////\n  // INIT //\n  // ////////\n\n  const type = 'websocket'\n  const attributes = {\n    canChat: true,\n    logConnections: true,\n    logExits: true,\n    sendWelcomeMessage: true,\n    verbs: [\n      'quit',\n      'exit',\n      'documentation',\n      'roomAdd',\n      'roomLeave',\n      'roomView',\n      'detailsView',\n      'say'\n    ]\n  }\n\n  const server = new api.GenericServer(type, options, attributes)\n\n  // ////////////////////\n  // REQUIRED METHODS //\n  // ////////////////////\n\n  server.start = function (next) {\n    const webserver = api.servers.servers.web\n    server.server = new Primus(webserver.server, api.config.servers.websocket.server)\n\n    server.server.on('connection', (rawConnection) => {\n      handleConnection(rawConnection)\n    })\n\n    server.server.on('disconnection', (rawConnection) => {\n      handleDisconnection(rawConnection)\n    })\n\n    api.log(['webSockets bound to %s: %s', webserver.options.bindIP, webserver.options.port], 'debug')\n    server.active = true\n\n    server.writeClientJS()\n\n    next()\n  }\n\n  server.stop = function (next) {\n    server.active = false\n    if (api.config.servers.websocket.destroyClientsOnShutdown === true) {\n      server.connections().forEach((connection) => {\n        connection.destroy()\n      })\n    }\n    process.nextTick(next)\n  }\n\n  server.sendMessage = function (connection, message, messageCount) {\n    if (message.error) {\n      message.error = api.config.errors.serializers.servers.websocket(message.error)\n    }\n\n    if (!message.context) { message.context = 'response' }\n    if (!messageCount) { messageCount = connection.messageCount }\n    if (message.context === 'response' && !message.messageCount) { message.messageCount = messageCount }\n    connection.rawConnection.write(message)\n  }\n\n  server.sendFile = function (connection, error, fileStream, mime, length, lastModified) {\n    let content = ''\n    let response = {\n      error: error,\n      content: null,\n      mime: mime,\n      length: length,\n      lastModified: lastModified\n    }\n\n    try {\n      if (!error) {\n        fileStream.on('data', function (d) { content += d })\n        fileStream.on('end', () => {\n          response.content = content\n          server.sendMessage(connection, response, connection.messageCount)\n        })\n      } else {\n        server.sendMessage(connection, response, connection.messageCount)\n      }\n    } catch (e) {\n      api.log(e, 'warning')\n      server.sendMessage(connection, response, connection.messageCount)\n    }\n  }\n\n  server.goodbye = function (connection) {\n    connection.rawConnection.end()\n  }\n\n  // //////////\n  // EVENTS //\n  // //////////\n\n  server.on('connection', function (connection) {\n    connection.rawConnection.on('data', (data) => {\n      handleData(connection, data)\n    })\n  })\n\n  server.on('actionComplete', function (data) {\n    if (data.toRender !== false) {\n      data.connection.response.messageCount = data.messageCount\n      server.sendMessage(data.connection, data.response, data.messageCount)\n    }\n  })\n\n  // //////////\n  // CLIENT //\n  // //////////\n\n  server.compileActionheroClientJS = function () {\n    let ahClientSource = fs.readFileSync(path.join(__dirname, '/../client/actionheroClient.js')).toString()\n    let url = api.config.servers.websocket.clientUrl\n    ahClientSource = ahClientSource.replace(/%%URL%%/g, url)\n    let defaults = {}\n    for (let i in api.config.servers.websocket.client) {\n      defaults[i] = api.config.servers.websocket.client[i]\n    }\n    defaults.url = url\n    let defaultsString = util.inspect(defaults)\n    defaultsString = defaultsString.replace('\\'window.location.origin\\'', 'window.location.origin')\n    ahClientSource = ahClientSource.replace('%%DEFAULTS%%', 'return ' + defaultsString)\n\n    return ahClientSource\n  }\n\n  server.renderClientJS = function (minimize) {\n    if (!minimize) { minimize = false }\n    let libSource = api.servers.servers.websocket.server.library()\n    let ahClientSource = server.compileActionheroClientJS()\n    ahClientSource =\n      ';;;\\r\\n' +\n      '(function(exports){ \\r\\n' +\n      ahClientSource +\n      '\\r\\n' +\n      'exports.ActionheroClient = ActionheroClient; \\r\\n' +\n      'exports.actionheroClient = actionheroClient; \\r\\n' +\n      '})(typeof exports === \\'undefined\\' ? window : exports);'\n    if (minimize) {\n      return UglifyJS.minify(libSource + '\\r\\n\\r\\n\\r\\n' + ahClientSource, {fromString: true}).code\n    } else {\n      return (libSource + '\\r\\n\\r\\n\\r\\n' + ahClientSource)\n    }\n  }\n\n  server.writeClientJS = function () {\n    if (!api.config.general.paths['public'] || api.config.general.paths['public'].length === 0) {\n      return\n    }\n    if (api.config.servers.websocket.clientJsPath && api.config.servers.websocket.clientJsName) {\n      let clientJSPath = path.normalize(\n        api.config.general.paths['public'][0] +\n        path.sep +\n        api.config.servers.websocket.clientJsPath +\n        path.sep\n      )\n      let clientJSName = api.config.servers.websocket.clientJsName\n      let clientJSFullPath = clientJSPath + clientJSName\n      try {\n        if (!fs.existsSync(clientJSPath)) {\n          fs.mkdirSync(clientJSPath)\n        }\n        fs.writeFileSync(clientJSFullPath + '.js', server.renderClientJS(false))\n        api.log(['wrote %s.js', clientJSFullPath], 'debug')\n        fs.writeFileSync(clientJSFullPath + '.min.js', server.renderClientJS(true))\n        api.log(['wrote %s.min.js', clientJSFullPath], 'debug')\n      } catch (e) {\n        api.log('Cannot write client-side JS for websocket server:', 'warning')\n        api.log(e, 'warning')\n        throw e\n      }\n    }\n  }\n\n  // ///////////\n  // HELPERS //\n  // ///////////\n\n  const handleConnection = function (rawConnection) {\n    const parsedCookies = browserFingerprint.parseCookies(rawConnection)\n    const fingerprint = parsedCookies[api.config.servers.web.fingerprintOptions.cookieKey]\n    server.buildConnection({\n      rawConnection: rawConnection,\n      remoteAddress: rawConnection.address.ip,\n      remotePort: rawConnection.address.port,\n      fingerprint: fingerprint\n    })\n  }\n\n  const handleDisconnection = function (rawConnection) {\n    for (let i in server.connections()) {\n      if (server.connections()[i] && rawConnection.id === server.connections()[i].rawConnection.id) {\n        server.connections()[i].destroy()\n        break\n      }\n    }\n  }\n\n  const handleData = function (connection, data) {\n    const verb = data.event\n    delete data.event\n    connection.messageCount++\n    connection.params = {}\n    if (verb === 'action') {\n      for (let v in data.params) {\n        connection.params[v] = data.params[v]\n      }\n      connection.error = null\n      connection.response = {}\n      server.processAction(connection)\n    } else if (verb === 'file') {\n      connection.params = {\n        file: data.file\n      }\n      server.processFile(connection)\n    } else {\n      let words = []\n      let message\n      if (data.room) {\n        words.push(data.room)\n        delete data.room\n      }\n      for (let i in data) { words.push(data[i]) }\n      connection.verbs(verb, words, (error, data) => {\n        if (!error) {\n          message = {status: 'OK', context: 'response', data: data}\n          server.sendMessage(connection, message)\n        } else {\n          message = {status: error, context: 'response', data: data}\n          server.sendMessage(connection, message)\n        }\n      })\n    }\n  }\n\n  next(server)\n}\n\n// ///////////////////////////////////////////////////////////////////\n// exports\nexports.initialize = initialize\n","/home/travis/build/npmtest/node-npmtest-actionhero/node_modules/actionhero/tasks/runAction.js":"const task = {\n  name: 'runAction',\n  description: 'I will run an action and return the connection object',\n  queue: 'default',\n  plugins: [],\n  pluginOptions: [],\n  frequency: 0,\n  run: function (api, params, next) {\n    if (!params) { params = {} }\n\n    const connection = new api.Connection({\n      type: 'task',\n      remotePort: '0',\n      remoteIP: '0',\n      rawConnection: {}\n    })\n\n    connection.params = params\n\n    const ActionProcessor = new api.ActionProcessor(connection, function (data) {\n      if (data.response.error) {\n        api.log('task error: ' + data.response.error, 'error', {params: JSON.stringify(params)})\n      } else {\n        api.log('[ action @ task ]', 'debug', {params: JSON.stringify(params)})\n      }\n\n      connection.destroy(function () {\n        next(data.response.error, data.response)\n      })\n    })\n\n    ActionProcessor.processAction()\n  }\n}\n\nexports.task = task\n","/home/travis/build/npmtest/node-npmtest-actionhero/node_modules/actionhero/bin/methods/console.js":"'use strict'\n\nconst REPL = require('repl')\n\nmodule.exports = function (api, next) {\n  for (let i in api.config.servers) { api.config.servers[i].enabled = false }\n  api.config.general.developmentMode = false\n  api.config.tasks.scheduler = false\n  api.config.tasks.queues = []\n  api.config.tasks.minTaskProcessors = 0\n  api.config.tasks.maxTaskProcessors = 0\n\n  api.commands.start.call(api._context, function (error) {\n    if (error) { return next(error) }\n\n    setTimeout(function () {\n      const repl = REPL.start({\n        prompt: '[ AH::' + api.env + ' ] >> ',\n        input: process.stdin,\n        output: process.stdout,\n        useGlobal: false\n      })\n\n      repl.context.api = api\n\n      repl.on('exit', function () {\n        next(null, true)\n      })\n    }, 500)\n  })\n}\n","/home/travis/build/npmtest/node-npmtest-actionhero/node_modules/actionhero/bin/methods/generate.js":"'use strict'\n\nconst fs = require('fs')\nconst path = require('path')\n\nmodule.exports = function (api, next) {\n  // proxy the logger, as we can't use the real one yet\n  api.log = function (message) {\n    console.log(message)\n  }\n\n  // reload utils, as they won't have been loaded yet\n  api.utils = require(path.normalize(path.join(__dirname, '/../../initializers/utils.js'))).initialize(api, function (error) {\n    if (error) { return next(error) }\n\n    // ////// DOCUMENTS ////////\n\n    let documents = {}\n\n    documents.projectMap = fs.readFileSync(path.join(__dirname, '/../templates/projectMap.txt'))\n\n    const oldFileMap = {\n      configApiJs: '/config/api.js',\n      configLoggerJs: '/config/logger.js',\n      configRedisJs: '/config/redis.js',\n      configTasksJs: '/config/tasks.js',\n      configErrorsJs: '/config/errors.js',\n      configI18nJs: '/config/i18n.js',\n      configRoutesJs: '/config/routes.js',\n      configSocketJs: '/config/servers/socket.js',\n      configWebJs: '/config/servers/web.js',\n      configWebsocketJs: '/config/servers/websocket.js',\n      packageJson: '/package.json',\n      actionStatus: '/actions/status.js',\n      actionChatRoom: '/actions/createChatRoom.js',\n      actionDocumentation: '/actions/showDocumentation.js',\n      publicIndex: '/public/index.html',\n      publicChat: '/public/chat.html',\n      publicLogo: '/public/logo/actionhero.png',\n      publicCss: '/public/css/cosmo.css',\n      exampleTest: '/test/template.js.example'\n    }\n\n    for (let name in oldFileMap) {\n      documents[name] = fs.readFileSync(path.join(__dirname, '/../../', oldFileMap[name]))\n    }\n\n    const AHversionNumber = JSON.parse(documents.packageJson).version\n\n    documents.packageJson = String(fs.readFileSync(path.join(__dirname, '/../templates/package.json')))\n    documents.packageJson = documents.packageJson.replace('%%versionNumber%%', AHversionNumber)\n    documents.readmeMd = String(fs.readFileSync(path.join(__dirname, '/../templates/README.md')))\n\n    // ////// LOGIC ////////\n\n    api.log('Generating a new actionhero project...');\n\n    // make directories\n    [\n      '/actions',\n      '/pids',\n      '/config',\n      '/config/servers',\n      '/initializers',\n      '/log',\n      '/servers',\n      '/public',\n      '/public/javascript',\n      '/public/css',\n      '/public/logo',\n      '/tasks',\n      '/test'\n    ].forEach(function (dir) {\n      api.utils.createDirSafely(api.projectRoot + dir)\n    })\n\n    // make files\n    const newFileMap = {\n      '/config/api.js': 'configApiJs',\n      '/config/logger.js': 'configLoggerJs',\n      '/config/redis.js': 'configRedisJs',\n      '/config/tasks.js': 'configTasksJs',\n      '/config/errors.js': 'configErrorsJs',\n      '/config/i18n.js': 'configI18nJs',\n      '/config/routes.js': 'configRoutesJs',\n      '/config/servers/socket.js': 'configSocketJs',\n      '/config/servers/web.js': 'configWebJs',\n      '/config/servers/websocket.js': 'configWebsocketJs',\n      '/package.json': 'packageJson',\n      '/actions/status.js': 'actionStatus',\n      '/actions/createChatRoom.js': 'actionChatRoom',\n      '/actions/showDocumentation.js': 'actionDocumentation',\n      '/public/index.html': 'publicIndex',\n      '/public/chat.html': 'publicChat',\n      '/public/css/cosmo.css': 'publicCss',\n      '/public/logo/actionhero.png': 'publicLogo',\n      '/README.md': 'readmeMd',\n      '/test/example.js': 'exampleTest'\n    }\n\n    for (let file in newFileMap) {\n      api.utils.createFileSafely(api.projectRoot + file, documents[newFileMap[file]])\n    }\n\n    api.log('')\n    api.log('Generation Complete.  Your project directory should look like this:')\n\n    api.log('')\n    documents.projectMap.toString().split('\\n').forEach(function (line) {\n      api.log(line)\n    })\n\n    api.log('You may need to run `npm install` to install some dependancies', 'alert')\n    api.log('Run \\'npm start\\' to start your server')\n\n    next(null, true)\n  })\n}\n","/home/travis/build/npmtest/node-npmtest-actionhero/node_modules/actionhero/bin/methods/help.js":"'use strict'\n\nconst fs = require('fs')\nconst path = require('path')\n\nmodule.exports = function (api, next) {\n  const help = fs.readFileSync(path.join(__dirname, '/../templates/help.txt')).toString()\n  help.split('\\n').forEach(function (line) { console.log(line) })\n  next(null, true)\n}\n","/home/travis/build/npmtest/node-npmtest-actionhero/node_modules/actionhero/bin/methods/link.js":"'use strict'\n\n// use me to include the files from a plugin within this project\nconst path = require('path')\nconst fs = require('fs')\nconst optimist = require('optimist')\nconst argv = optimist\n  .demand('name')\n  .describe('name', 'The name of the plugin')\n  .describe('overwriteConfig', 'Should we overwrite existing config files for this plugin?')\n  .default('overwriteConfig', false)\n  .argv\n\nmodule.exports = function (api, next) {\n  let linkRelativeBase = api.projectRoot + path.sep\n  let pluginRoot\n  let overwriteConfig = false\n\n  api.config.general.paths.plugin.forEach(function (pluginPath) {\n    let pluginPathAttempt = path.normalize(pluginPath + path.sep + argv.name)\n    if (!pluginRoot && api.utils.dirExists(pluginPath + path.sep + argv.name)) {\n      pluginRoot = pluginPathAttempt\n    }\n  })\n\n  if (!pluginRoot) {\n    api.log(['plugin `%s` not found in plugin paths', argv.name], 'warning', api.config.general.paths.plugin)\n    return next(null, true)\n  }\n\n  let pluginRootRelative = pluginRoot.replace(linkRelativeBase, '')\n  api.log(['linking the plugin found at %s', pluginRootRelative]);\n\n  // link actionable files\n  [\n    ['action', 'actions'],\n    ['task', 'tasks'],\n    ['public', 'public'],\n    ['server', 'servers'],\n    ['initializer', 'initializers']\n  ].forEach(function (c) {\n    let localLinkDirectory = api.config.general.paths[c[0]][0] + path.sep + 'plugins'\n    let localLinkLocation = path.normalize(localLinkDirectory + path.sep + argv.name + '.link')\n    let pluginSubSection = path.normalize(pluginRootRelative + path.sep + c[1])\n\n    if (api.utils.dirExists(pluginSubSection)) {\n      api.utils.createDirSafely(localLinkDirectory)\n      api.utils.createLinkfileSafely(localLinkLocation, c[1], pluginSubSection)\n    }\n  })\n\n  const copyFiles = function (dir, prepend) {\n    if (!prepend) { prepend = '' }\n    if (api.utils.dirExists(dir)) {\n      fs.readdirSync(dir).forEach(function (pluginConfigFile) {\n        const file = path.normalize(dir + path.sep + pluginConfigFile)\n        const stats = fs.lstatSync(file)\n        if (stats.isDirectory()) {\n          copyFiles(file, (prepend + path.sep + pluginConfigFile + path.sep))\n        } else {\n          const content = fs.readFileSync(file)\n          const fileParts = pluginConfigFile.split(path.sep)\n          let localConfigFile = linkRelativeBase + 'config' + path.sep + prepend + fileParts[(fileParts.length - 1)]\n          if (process.env.ACTIONHERO_CONFIG) {\n            localConfigFile = process.env.ACTIONHERO_CONFIG + path.sep + prepend + fileParts[(fileParts.length - 1)]\n          }\n          api.utils.createFileSafely(path.normalize(localConfigFile), content, overwriteConfig)\n        }\n      })\n    }\n  }\n\n  // copy config files\n  const pluginConfigDir = pluginRoot + path.sep + 'config'\n  copyFiles(pluginConfigDir)\n  next(null, true)\n}\n","/home/travis/build/npmtest/node-npmtest-actionhero/node_modules/actionhero/bin/methods/start.js":"'use strict'\n\nconst cluster = require('cluster')\nconst readline = require('readline')\nconst os = require('os')\n\nmodule.exports = function (api, next) {\n  let state\n\n  // number of ms to wait to do a forcible shutdown if actionhero won't stop gracefully\n  let shutdownTimeout = 1000 * 30\n  if (process.env.ACTIONHERO_SHUTDOWN_TIMEOUT) {\n    shutdownTimeout = parseInt(process.env.ACTIONHERO_SHUTDOWN_TIMEOUT)\n  }\n\n  const startServer = function (callback) {\n    state = 'starting'\n    if (cluster.isWorker) { process.send({state: state}) }\n    api._context.start(function (error, apiFromCallback) {\n      if (error) {\n        api.log(['%s', error])\n        process.exit(1)\n      } else {\n        state = 'started'\n        if (cluster.isWorker) { process.send({state: state}) }\n        api = apiFromCallback\n        checkForInernalStop()\n        if (typeof callback === 'function') { callback(null, api) }\n      }\n    })\n  }\n\n  const stopServer = function (callback) {\n    state = 'stopping'\n    if (cluster.isWorker) { process.send({state: state}) }\n    api._context.stop(function () {\n      state = 'stopped'\n      if (cluster.isWorker) { process.send({state: state}) }\n      api = null\n      if (typeof callback === 'function') { callback(null, api) }\n    })\n  }\n\n  const restartServer = function (callback) {\n    state = 'restarting'\n    if (cluster.isWorker) { process.send({state: state}) }\n    api._context.restart(function (error, apiFromCallback) {\n      if (error) { throw (error) }\n\n      state = 'started'\n      if (cluster.isWorker) { process.send({state: state}) }\n      api = apiFromCallback\n      if (typeof callback === 'function') { callback(null, api) }\n    })\n  }\n\n  const stopProcess = function () {\n    setTimeout(function () {\n      throw new Error('process stop timeout reached.  terminating now.')\n    }, shutdownTimeout)\n    // finalTimer.unref();\n    stopServer(function () {\n      process.nextTick(function () {\n        process.exit()\n      })\n    })\n  }\n\n  let checkForInernalStopTimer\n  const checkForInernalStop = function () {\n    clearTimeout(checkForInernalStopTimer)\n    if (api.running !== true && state === 'started') {\n      process.exit(0)\n    }\n    checkForInernalStopTimer = setTimeout(checkForInernalStop, shutdownTimeout)\n  }\n\n  if (cluster.isWorker) {\n    process.on('message', function (msg) {\n      if (msg === 'start') {\n        startServer()\n      } else if (msg === 'stop') {\n        stopServer()\n      } else if (msg === 'stopProcess') {\n        stopProcess()\n      // in cluster, we cannot re-bind the port\n      // so kill this worker, and then let the cluster start a new worker\n      } else if (msg === 'restart') { stopProcess() }\n    })\n\n    process.on('uncaughtException', function (error) {\n      let stack\n      try {\n        stack = error.stack.split(os.EOL)\n      } catch (e) {\n        stack = [error]\n      }\n      process.send({uncaughtException: {\n        message: error.message,\n        stack: stack\n      }})\n      process.nextTick(process.exit)\n    })\n\n    process.on('unhandledRejection', function (reason, p) {\n      process.send({unhandledRejection: {reason: reason, p: p}})\n      process.nextTick(process.exit)\n    })\n  }\n\n  process.on('SIGINT', function () { stopProcess() })\n  process.on('SIGTERM', function () { stopProcess() })\n  process.on('SIGUSR2', function () { restartServer() })\n\n  if (process.platform === 'win32' && !process.env.IISNODE_VERSION) {\n    const rl = readline.createInterface({\n      input: process.stdin,\n      output: process.stdout\n    })\n    rl.on('SIGINT', function () {\n      process.emit('SIGINT')\n    })\n  }\n\n  // start the server!\n  startServer(function () {\n    next(false)\n  })\n}\n","/home/travis/build/npmtest/node-npmtest-actionhero/node_modules/actionhero/bin/methods/unlink.js":"'use strict'\n\n// use me to exclude the files from a plugin within this project\nconst path = require('path')\nconst optimist = require('optimist')\nconst argv = optimist\n  .demand('name')\n  .describe('name', 'The name of the plugin')\n  .argv\n\nmodule.exports = function (api, next) {\n  const linkRelativeBase = api.projectRoot + path.sep\n  let pluginRoot\n\n  api.config.general.paths.plugin.forEach(function (pluginPath) {\n    const pluginPathAttempt = path.normalize(pluginPath + path.sep + argv.name)\n    if (!pluginRoot && api.utils.dirExists(pluginPath + path.sep + argv.name)) {\n      pluginRoot = pluginPathAttempt\n    }\n  })\n\n  if (!pluginRoot) {\n    api.log(['plugin `%s` not found in plugin paths', argv.name], 'warning', api.config.general.paths.plugin)\n    return next(null, true)\n  }\n\n  const pluginRootRelative = pluginRoot.replace(linkRelativeBase, '')\n  api.log(['unlinking the plugin found at %s', pluginRootRelative]);\n\n  // unlink actionable files\n  [\n    ['action', 'actions'],\n    ['task', 'tasks'],\n    ['public', 'public'],\n    ['server', 'servers'],\n    ['initializer', 'initializers']\n  ].forEach(function (c) {\n    const localLinkDirectory = path.normalize(api.config.general.paths[c[0]][0] + path.sep + 'plugins')\n    const localLinkLocation = path.normalize(localLinkDirectory + path.sep + argv.name + '.link')\n\n    if (api.utils.dirExists(localLinkDirectory)) {\n      api.utils.removeLinkfileSafely(localLinkLocation)\n    }\n  })\n\n  api.log('Remember that config files have to be deleted manually', 'warning')\n  api.log('If your plugin was installed via NPM, also be sure to remove it from your package.json or uninstall it with \"npm uninstall --save\"', 'warning')\n  next(null, true)\n}\n","/home/travis/build/npmtest/node-npmtest-actionhero/node_modules/actionhero/bin/methods/version.js":"'use strict'\n\nconst path = require('path')\nconst packageJSON = require(path.join(__dirname, '/../../package.json'))\n\nmodule.exports = function (api, next) {\n  console.log(packageJSON.version)\n  next(null, true)\n}\n","/home/travis/build/npmtest/node-npmtest-actionhero/node_modules/actionhero/bin/templates/action.js":"'use strict'\n\nexports.action = {\n  name: '%%name%%',\n  description: '%%description%%',\n  blockedConnectionTypes: [],\n  outputExample: {},\n  matchExtensionMimeType: false,\n  version: 1.0,\n  toDocument: true,\n  middleware: [],\n\n  inputs: {},\n\n  run: function (api, data, next) {\n    let error = null\n    // your logic here\n    next(error)\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-actionhero/node_modules/actionhero/bin/templates/initializer.js":"'use strict'\n\nmodule.exports = {\n  loadPriority: %%loadPriority%%,\n  startPriority: %%startPriority%%,\n  stopPriority: %%stopPriority%%,\n  initialize: function (api, next) {\n    api.%%name%% = {}\n\n    next()\n  },\n  start: function (api, next) {\n    next()\n  },\n  stop: function (api, next) {\n    next()\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-actionhero/node_modules/actionhero/bin/templates/server.js":"'use strict'\n\nconst initialize = function (api, options, next) {\n  // ////////\n  // INIT //\n  // ////////\n\n  const type = '%%name%%'\n\n  const attributes = {\n    canChat: true,\n    logConnections: true,\n    logExits: true,\n    sendWelcomeMessage: true,\n    verbs: []\n  }\n\n  const server = new api.GenericServer(type, options, attributes)\n\n  // ////////////////////\n  // REQUIRED METHODS //\n  // ////////////////////\n\n  server.start = function (next) {\n    next()\n  }\n\n  server.stop = function (next) {\n    next()\n  }\n\n  server.sendMessage = function (connection, message, messageCount) {\n\n  }\n\n  server.sendFile = function (connection, error, fileStream, mime, length) {\n\n  }\n\n  server.goodbye = function (connection, reason) {\n\n  }\n\n  // //////////\n  // EVENTS //\n  // //////////\n\n  server.on('connection', function (connection) {\n\n  })\n\n  server.on('actionComplete', function (data) {\n\n  })\n\n  // ///////////\n  // HELPERS //\n  // ///////////\n\n  next(server)\n}\n\nexports.initialize = initialize\n","/home/travis/build/npmtest/node-npmtest-actionhero/node_modules/actionhero/bin/templates/task.js":"'use strict'\n\nexports.task = {\n  name: '%%name%%',\n  description: '%%description%%',\n  frequency: %%frequency%%,\n  queue: '%%queue%%',\n  middleware: [],\n\n  run: function (api, params, next) {\n    // your logic here\n    // let error = new Error('something has gone wrong')\n    // let resultLogMessage = {taskResult: 'ok'}\n    // next(error, resultLogMessage)\n\n    next()\n  }\n}\n"}